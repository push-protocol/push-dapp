import { fA as S, eH as Qt, ie as ge, __tla as __tla_0 } from "./index-AGa8OPve.js";
let Mr;
let __tla = Promise.all([
  (() => {
    try {
      return __tla_0;
    } catch {
    }
  })()
]).then(async () => {
  const bs = (t, e) => {
    let n;
    switch (t) {
      case "standard":
        return n = e, `data:image/svg+xml,%3Csvg width='${e}' height='${n}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
      case "circle":
        return n = e, `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${e}' height='${n}' viewBox='0 0 999.81 999.81'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052fe;%7D.cls-2%7Bfill:%23fefefe;%7D.cls-3%7Bfill:%230152fe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M655-115.9h56c.83,1.59,2.36.88,3.56,1a478,478,0,0,1,75.06,10.42C891.4-81.76,978.33-32.58,1049.19,44q116.7,126,131.94,297.61c.38,4.14-.34,8.53,1.78,12.45v59c-1.58.84-.91,2.35-1,3.56a482.05,482.05,0,0,1-10.38,74.05c-24,106.72-76.64,196.76-158.83,268.93s-178.18,112.82-287.2,122.6c-4.83.43-9.86-.25-14.51,1.77H654c-1-1.68-2.69-.91-4.06-1a496.89,496.89,0,0,1-105.9-18.59c-93.54-27.42-172.78-77.59-236.91-150.94Q199.34,590.1,184.87,426.58c-.47-5.19.25-10.56-1.77-15.59V355c1.68-1,.91-2.7,1-4.06a498.12,498.12,0,0,1,18.58-105.9c26-88.75,72.64-164.9,140.6-227.57q126-116.27,297.21-131.61C645.32-114.57,650.35-113.88,655-115.9Zm377.92,500c0-192.44-156.31-349.49-347.56-350.15-194.13-.68-350.94,155.13-352.29,347.42-1.37,194.55,155.51,352.1,348.56,352.47C876.15,734.23,1032.93,577.84,1032.93,384.11Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-2' d='M1032.93,384.11c0,193.73-156.78,350.12-351.29,349.74-193-.37-349.93-157.92-348.56-352.47C334.43,189.09,491.24,33.28,685.37,34,876.62,34.62,1032.94,191.67,1032.93,384.11ZM683,496.81q43.74,0,87.48,0c15.55,0,25.32-9.72,25.33-25.21q0-87.48,0-175c0-15.83-9.68-25.46-25.59-25.46H595.77c-15.88,0-25.57,9.64-25.58,25.46q0,87.23,0,174.45c0,16.18,9.59,25.7,25.84,25.71Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-3' d='M683,496.81H596c-16.25,0-25.84-9.53-25.84-25.71q0-87.23,0-174.45c0-15.82,9.7-25.46,25.58-25.46H770.22c15.91,0,25.59,9.63,25.59,25.46q0,87.47,0,175c0,15.49-9.78,25.2-25.33,25.21Q726.74,496.84,683,496.81Z' transform='translate(-183.1 115.9)'/%3E%3C/svg%3E`;
      case "text":
        return n = (0.1 * e).toFixed(2), `data:image/svg+xml,%3Csvg width='${e}' height='${n}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
      case "textWithLogo":
        return n = (0.25 * e).toFixed(2), `data:image/svg+xml,%3Csvg width='${e}' height='${n}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
      case "textLight":
        return n = (0.1 * e).toFixed(2), `data:image/svg+xml,%3Csvg width='${e}' height='${n}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
      case "textWithLogoLight":
        return n = (0.25 * e).toFixed(2), `data:image/svg+xml,%3Csvg width='${e}' height='${n}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
      default:
        return n = e, `data:image/svg+xml,%3Csvg width='${e}' height='${n}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
    }
  };
  class K {
    constructor(e, n) {
      this.scope = e, this.module = n;
    }
    storeObject(e, n) {
      this.setItem(e, JSON.stringify(n));
    }
    loadObject(e) {
      const n = this.getItem(e);
      return n ? JSON.parse(n) : void 0;
    }
    setItem(e, n) {
      localStorage.setItem(this.scopedKey(e), n);
    }
    getItem(e) {
      return localStorage.getItem(this.scopedKey(e));
    }
    removeItem(e) {
      localStorage.removeItem(this.scopedKey(e));
    }
    clear() {
      const e = this.scopedKey(""), n = [];
      for (let s = 0; s < localStorage.length; s++) {
        const i = localStorage.key(s);
        typeof i == "string" && i.startsWith(e) && n.push(i);
      }
      n.forEach((s) => localStorage.removeItem(s));
    }
    scopedKey(e) {
      return `-${this.scope}${this.module ? `:${this.module}` : ""}:${e}`;
    }
    static clearAll() {
      new K("CBWSDK").clear(), new K("walletlink").clear();
    }
  }
  const M = {
    rpc: {
      invalidInput: -32e3,
      resourceNotFound: -32001,
      resourceUnavailable: -32002,
      transactionRejected: -32003,
      methodNotSupported: -32004,
      limitExceeded: -32005,
      parse: -32700,
      invalidRequest: -32600,
      methodNotFound: -32601,
      invalidParams: -32602,
      internal: -32603
    },
    provider: {
      userRejectedRequest: 4001,
      unauthorized: 4100,
      unsupportedMethod: 4200,
      disconnected: 4900,
      chainDisconnected: 4901,
      unsupportedChain: 4902
    }
  }, ze = {
    "-32700": {
      standard: "JSON RPC 2.0",
      message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    },
    "-32600": {
      standard: "JSON RPC 2.0",
      message: "The JSON sent is not a valid Request object."
    },
    "-32601": {
      standard: "JSON RPC 2.0",
      message: "The method does not exist / is not available."
    },
    "-32602": {
      standard: "JSON RPC 2.0",
      message: "Invalid method parameter(s)."
    },
    "-32603": {
      standard: "JSON RPC 2.0",
      message: "Internal JSON-RPC error."
    },
    "-32000": {
      standard: "EIP-1474",
      message: "Invalid input."
    },
    "-32001": {
      standard: "EIP-1474",
      message: "Resource not found."
    },
    "-32002": {
      standard: "EIP-1474",
      message: "Resource unavailable."
    },
    "-32003": {
      standard: "EIP-1474",
      message: "Transaction rejected."
    },
    "-32004": {
      standard: "EIP-1474",
      message: "Method not supported."
    },
    "-32005": {
      standard: "EIP-1474",
      message: "Request limit exceeded."
    },
    4001: {
      standard: "EIP-1193",
      message: "User rejected the request."
    },
    4100: {
      standard: "EIP-1193",
      message: "The requested account and/or method has not been authorized by the user."
    },
    4200: {
      standard: "EIP-1193",
      message: "The requested method is not supported by this Ethereum provider."
    },
    4900: {
      standard: "EIP-1193",
      message: "The provider is disconnected from all chains."
    },
    4901: {
      standard: "EIP-1193",
      message: "The provider is disconnected from the specified chain."
    },
    4902: {
      standard: "EIP-3085",
      message: "Unrecognized chain ID."
    }
  }, Xt = "Unspecified error message.", ws = "Unspecified server error.";
  function it(t, e = Xt) {
    if (t && Number.isInteger(t)) {
      const n = t.toString();
      if (Ze(ze, n)) return ze[n].message;
      if (en(t)) return ws;
    }
    return e;
  }
  function vs(t) {
    if (!Number.isInteger(t)) return false;
    const e = t.toString();
    return !!(ze[e] || en(t));
  }
  function ks(t, { shouldIncludeStack: e = false } = {}) {
    const n = {};
    if (t && typeof t == "object" && !Array.isArray(t) && Ze(t, "code") && vs(t.code)) {
      const s = t;
      n.code = s.code, s.message && typeof s.message == "string" ? (n.message = s.message, Ze(s, "data") && (n.data = s.data)) : (n.message = it(n.code), n.data = {
        originalError: bt(t)
      });
    } else n.code = M.rpc.internal, n.message = wt(t, "message") ? t.message : Xt, n.data = {
      originalError: bt(t)
    };
    return e && (n.stack = wt(t, "stack") ? t.stack : void 0), n;
  }
  function en(t) {
    return t >= -32099 && t <= -32e3;
  }
  function bt(t) {
    return t && typeof t == "object" && !Array.isArray(t) ? Object.assign({}, t) : t;
  }
  function Ze(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }
  function wt(t, e) {
    return typeof t == "object" && t !== null && e in t && typeof t[e] == "string";
  }
  const v = {
    rpc: {
      parse: (t) => j(M.rpc.parse, t),
      invalidRequest: (t) => j(M.rpc.invalidRequest, t),
      invalidParams: (t) => j(M.rpc.invalidParams, t),
      methodNotFound: (t) => j(M.rpc.methodNotFound, t),
      internal: (t) => j(M.rpc.internal, t),
      server: (t) => {
        if (!t || typeof t != "object" || Array.isArray(t)) throw new Error("Ethereum RPC Server errors must provide single object argument.");
        const { code: e } = t;
        if (!Number.isInteger(e) || e > -32005 || e < -32099) throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
        return j(e, t);
      },
      invalidInput: (t) => j(M.rpc.invalidInput, t),
      resourceNotFound: (t) => j(M.rpc.resourceNotFound, t),
      resourceUnavailable: (t) => j(M.rpc.resourceUnavailable, t),
      transactionRejected: (t) => j(M.rpc.transactionRejected, t),
      methodNotSupported: (t) => j(M.rpc.methodNotSupported, t),
      limitExceeded: (t) => j(M.rpc.limitExceeded, t)
    },
    provider: {
      userRejectedRequest: (t) => ce(M.provider.userRejectedRequest, t),
      unauthorized: (t) => ce(M.provider.unauthorized, t),
      unsupportedMethod: (t) => ce(M.provider.unsupportedMethod, t),
      disconnected: (t) => ce(M.provider.disconnected, t),
      chainDisconnected: (t) => ce(M.provider.chainDisconnected, t),
      unsupportedChain: (t) => ce(M.provider.unsupportedChain, t),
      custom: (t) => {
        if (!t || typeof t != "object" || Array.isArray(t)) throw new Error("Ethereum Provider custom errors must provide single object argument.");
        const { code: e, message: n, data: s } = t;
        if (!n || typeof n != "string") throw new Error('"message" must be a nonempty string');
        return new sn(e, n, s);
      }
    }
  };
  function j(t, e) {
    const [n, s] = tn(e);
    return new nn(t, n || it(t), s);
  }
  function ce(t, e) {
    const [n, s] = tn(e);
    return new sn(t, n || it(t), s);
  }
  function tn(t) {
    if (t) {
      if (typeof t == "string") return [
        t
      ];
      if (typeof t == "object" && !Array.isArray(t)) {
        const { message: e, data: n } = t;
        if (e && typeof e != "string") throw new Error("Must specify string message.");
        return [
          e || void 0,
          n
        ];
      }
    }
    return [];
  }
  class nn extends Error {
    constructor(e, n, s) {
      if (!Number.isInteger(e)) throw new Error('"code" must be an integer.');
      if (!n || typeof n != "string") throw new Error('"message" must be a nonempty string.');
      super(n), this.code = e, s !== void 0 && (this.data = s);
    }
  }
  class sn extends nn {
    constructor(e, n, s) {
      if (!Es(e)) throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
      super(e, n, s);
    }
  }
  function Es(t) {
    return Number.isInteger(t) && t >= 1e3 && t <= 4999;
  }
  function rt() {
    return (t) => t;
  }
  const be = rt(), Cs = rt(), xs = rt();
  function $(t) {
    return Math.floor(t);
  }
  const rn = /^[0-9]*$/, on = /^[a-f0-9]*$/;
  function se(t) {
    return ot(crypto.getRandomValues(new Uint8Array(t)));
  }
  function ot(t) {
    return [
      ...t
    ].map((e) => e.toString(16).padStart(2, "0")).join("");
  }
  function Ae(t) {
    return new Uint8Array(t.match(/.{1,2}/g).map((e) => Number.parseInt(e, 16)));
  }
  function _e(t, e = false) {
    const n = t.toString("hex");
    return be(e ? `0x${n}` : n);
  }
  function Be(t) {
    return _e(Ge(t), true);
  }
  function W(t) {
    return xs(t.toString(10));
  }
  function Q(t) {
    return be(`0x${BigInt(t).toString(16)}`);
  }
  function an(t) {
    return t.startsWith("0x") || t.startsWith("0X");
  }
  function at(t) {
    return an(t) ? t.slice(2) : t;
  }
  function cn(t) {
    return an(t) ? `0x${t.slice(2)}` : `0x${t}`;
  }
  function Oe(t) {
    if (typeof t != "string") return false;
    const e = at(t).toLowerCase();
    return on.test(e);
  }
  function Ss(t, e = false) {
    if (typeof t == "string") {
      const n = at(t).toLowerCase();
      if (on.test(n)) return be(e ? `0x${n}` : n);
    }
    throw v.rpc.invalidParams(`"${String(t)}" is not a hexadecimal string`);
  }
  function ct(t, e = false) {
    let n = Ss(t, false);
    return n.length % 2 === 1 && (n = be(`0${n}`)), e ? be(`0x${n}`) : n;
  }
  function G(t) {
    if (typeof t == "string") {
      const e = at(t).toLowerCase();
      if (Oe(e) && e.length === 40) return Cs(cn(e));
    }
    throw v.rpc.invalidParams(`Invalid Ethereum address: ${String(t)}`);
  }
  function Ge(t) {
    if (S.isBuffer(t)) return t;
    if (typeof t == "string") {
      if (Oe(t)) {
        const e = ct(t, false);
        return S.from(e, "hex");
      }
      return S.from(t, "utf8");
    }
    throw v.rpc.invalidParams(`Not binary data: ${String(t)}`);
  }
  function me(t) {
    if (typeof t == "number" && Number.isInteger(t)) return $(t);
    if (typeof t == "string") {
      if (rn.test(t)) return $(Number(t));
      if (Oe(t)) return $(Number(BigInt(ct(t, true))));
    }
    throw v.rpc.invalidParams(`Not an integer: ${String(t)}`);
  }
  function fe(t) {
    if (t !== null && (typeof t == "bigint" || Ls(t))) return BigInt(t.toString(10));
    if (typeof t == "number") return BigInt(me(t));
    if (typeof t == "string") {
      if (rn.test(t)) return BigInt(t);
      if (Oe(t)) return BigInt(ct(t, true));
    }
    throw v.rpc.invalidParams(`Not an integer: ${String(t)}`);
  }
  function Is(t) {
    if (typeof t == "string") return JSON.parse(t);
    if (typeof t == "object") return t;
    throw v.rpc.invalidParams(`Not a JSON string or an object: ${String(t)}`);
  }
  function Ls(t) {
    if (t == null || typeof t.constructor != "function") return false;
    const { constructor: e } = t;
    return typeof e.config == "function" && typeof e.EUCLID == "number";
  }
  function As() {
    const t = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]'), { protocol: e, host: n } = document.location, s = t ? t.getAttribute("href") : null;
    return !s || s.startsWith("javascript:") || s.startsWith("vbscript:") ? `${e}//${n}/favicon.ico` : s.startsWith("http://") || s.startsWith("https://") || s.startsWith("data:") ? s : s.startsWith("//") ? e + s : `${e}//${n}${s}`;
  }
  async function Ms() {
    return crypto.subtle.generateKey({
      name: "ECDH",
      namedCurve: "P-256"
    }, true, [
      "deriveKey"
    ]);
  }
  async function Ps(t, e) {
    return crypto.subtle.deriveKey({
      name: "ECDH",
      public: e
    }, t, {
      name: "AES-GCM",
      length: 256
    }, false, [
      "encrypt",
      "decrypt"
    ]);
  }
  async function Ts(t, e) {
    const n = crypto.getRandomValues(new Uint8Array(12)), s = await crypto.subtle.encrypt({
      name: "AES-GCM",
      iv: n
    }, t, new TextEncoder().encode(e));
    return {
      iv: n,
      cipherText: s
    };
  }
  async function Rs(t, { iv: e, cipherText: n }) {
    const s = await crypto.subtle.decrypt({
      name: "AES-GCM",
      iv: e
    }, t, n);
    return new TextDecoder().decode(s);
  }
  function ln(t) {
    switch (t) {
      case "public":
        return "spki";
      case "private":
        return "pkcs8";
    }
  }
  async function dn(t, e) {
    const n = ln(t), s = await crypto.subtle.exportKey(n, e);
    return ot(new Uint8Array(s));
  }
  async function hn(t, e) {
    const n = ln(t), s = Ae(e).buffer;
    return await crypto.subtle.importKey(n, new Uint8Array(s), {
      name: "ECDH",
      namedCurve: "P-256"
    }, true, t === "private" ? [
      "deriveKey"
    ] : []);
  }
  async function Ns(t, e) {
    const n = JSON.stringify(t, (s, i) => {
      if (!(i instanceof Error)) return i;
      const r = i;
      return Object.assign(Object.assign({}, r.code ? {
        code: r.code
      } : {}), {
        message: r.message
      });
    });
    return Ts(e, n);
  }
  async function Os(t, e) {
    return JSON.parse(await Rs(e, t));
  }
  const We = {
    storageKey: "ownPrivateKey",
    keyType: "private"
  }, qe = {
    storageKey: "ownPublicKey",
    keyType: "public"
  }, Ve = {
    storageKey: "peerPublicKey",
    keyType: "public"
  };
  class Ds {
    constructor() {
      this.storage = new K("CBWSDK", "SCWKeyManager"), this.ownPrivateKey = null, this.ownPublicKey = null, this.peerPublicKey = null, this.sharedSecret = null;
    }
    async getOwnPublicKey() {
      return await this.loadKeysIfNeeded(), this.ownPublicKey;
    }
    async getSharedSecret() {
      return await this.loadKeysIfNeeded(), this.sharedSecret;
    }
    async setPeerPublicKey(e) {
      this.sharedSecret = null, this.peerPublicKey = e, await this.storeKey(Ve, e), await this.loadKeysIfNeeded();
    }
    async clear() {
      this.ownPrivateKey = null, this.ownPublicKey = null, this.peerPublicKey = null, this.sharedSecret = null, this.storage.removeItem(qe.storageKey), this.storage.removeItem(We.storageKey), this.storage.removeItem(Ve.storageKey);
    }
    async generateKeyPair() {
      const e = await Ms();
      this.ownPrivateKey = e.privateKey, this.ownPublicKey = e.publicKey, await this.storeKey(We, e.privateKey), await this.storeKey(qe, e.publicKey);
    }
    async loadKeysIfNeeded() {
      if (this.ownPrivateKey === null && (this.ownPrivateKey = await this.loadKey(We)), this.ownPublicKey === null && (this.ownPublicKey = await this.loadKey(qe)), (this.ownPrivateKey === null || this.ownPublicKey === null) && await this.generateKeyPair(), this.peerPublicKey === null && (this.peerPublicKey = await this.loadKey(Ve)), this.sharedSecret === null) {
        if (this.ownPrivateKey === null || this.peerPublicKey === null) return;
        this.sharedSecret = await Ps(this.ownPrivateKey, this.peerPublicKey);
      }
    }
    async loadKey(e) {
      const n = this.storage.getItem(e.storageKey);
      return n ? hn(e.keyType, n) : null;
    }
    async storeKey(e, n) {
      const s = await dn(e.keyType, n);
      this.storage.setItem(e.storageKey, s);
    }
  }
  const ke = "4.3.0", un = "@coinbase/wallet-sdk";
  async function lt(t, e) {
    const n = Object.assign(Object.assign({}, t), {
      jsonrpc: "2.0",
      id: crypto.randomUUID()
    }), s = await window.fetch(e, {
      method: "POST",
      body: JSON.stringify(n),
      mode: "cors",
      headers: {
        "Content-Type": "application/json",
        "X-Cbw-Sdk-Version": ke,
        "X-Cbw-Sdk-Platform": un
      }
    }), { result: i, error: r } = await s.json();
    if (r) throw r;
    return i;
  }
  function Us() {
    return globalThis.coinbaseWalletExtension;
  }
  function Hs() {
    var t, e;
    try {
      const n = globalThis;
      return (t = n.ethereum) !== null && t !== void 0 ? t : (e = n.top) === null || e === void 0 ? void 0 : e.ethereum;
    } catch {
      return;
    }
  }
  function js({ metadata: t, preference: e }) {
    var n, s;
    const { appName: i, appLogoUrl: r, appChainIds: o } = t;
    if (e.options !== "smartWalletOnly") {
      const c = Us();
      if (c) return (n = c.setAppInfo) === null || n === void 0 || n.call(c, i, r, o, e), c;
    }
    const a = Hs();
    if (a == null ? void 0 : a.isCoinbaseBrowser) return (s = a.setAppInfo) === null || s === void 0 || s.call(a, i, r, o, e), a;
  }
  function Bs(t) {
    if (!t || typeof t != "object" || Array.isArray(t)) throw v.rpc.invalidParams({
      message: "Expected a single, non-array, object argument.",
      data: t
    });
    const { method: e, params: n } = t;
    if (typeof e != "string" || e.length === 0) throw v.rpc.invalidParams({
      message: "'args.method' must be a non-empty string.",
      data: t
    });
    if (n !== void 0 && !Array.isArray(n) && (typeof n != "object" || n === null)) throw v.rpc.invalidParams({
      message: "'args.params' must be an object or array if provided.",
      data: t
    });
    switch (e) {
      case "eth_sign":
      case "eth_signTypedData_v2":
      case "eth_subscribe":
      case "eth_unsubscribe":
        throw v.provider.unsupportedMethod();
    }
  }
  const vt = "accounts", kt = "activeChain", Et = "availableChains", Ct = "walletCapabilities";
  class Ws {
    constructor(e) {
      var n, s, i;
      this.metadata = e.metadata, this.communicator = e.communicator, this.callback = e.callback, this.keyManager = new Ds(), this.storage = new K("CBWSDK", "SCWStateManager"), this.accounts = (n = this.storage.loadObject(vt)) !== null && n !== void 0 ? n : [], this.chain = this.storage.loadObject(kt) || {
        id: (i = (s = e.metadata.appChainIds) === null || s === void 0 ? void 0 : s[0]) !== null && i !== void 0 ? i : 1
      }, this.handshake = this.handshake.bind(this), this.request = this.request.bind(this), this.createRequestMessage = this.createRequestMessage.bind(this), this.decryptResponseMessage = this.decryptResponseMessage.bind(this);
    }
    async handshake(e) {
      var n, s, i, r;
      await ((s = (n = this.communicator).waitForPopupLoaded) === null || s === void 0 ? void 0 : s.call(n));
      const o = await this.createRequestMessage({
        handshake: {
          method: e.method,
          params: Object.assign({}, this.metadata, (i = e.params) !== null && i !== void 0 ? i : {})
        }
      }), a = await this.communicator.postRequestAndWaitForResponse(o);
      if ("failure" in a.content) throw a.content.failure;
      const c = await hn("public", a.sender);
      await this.keyManager.setPeerPublicKey(c);
      const h = (await this.decryptResponseMessage(a)).result;
      if ("error" in h) throw h.error;
      switch (e.method) {
        case "eth_requestAccounts": {
          const l = h.value;
          this.accounts = l, this.storage.storeObject(vt, l), (r = this.callback) === null || r === void 0 || r.call(this, "accountsChanged", l);
          break;
        }
      }
    }
    async request(e) {
      var n;
      if (this.accounts.length === 0) switch (e.method) {
        case "wallet_sendCalls":
          return this.sendRequestToPopup(e);
        default:
          throw v.provider.unauthorized();
      }
      switch (e.method) {
        case "eth_requestAccounts":
          return (n = this.callback) === null || n === void 0 || n.call(this, "connect", {
            chainId: Q(this.chain.id)
          }), this.accounts;
        case "eth_accounts":
          return this.accounts;
        case "eth_coinbase":
          return this.accounts[0];
        case "net_version":
          return this.chain.id;
        case "eth_chainId":
          return Q(this.chain.id);
        case "wallet_getCapabilities":
          return this.storage.loadObject(Ct);
        case "wallet_switchEthereumChain":
          return this.handleSwitchChainRequest(e);
        case "eth_ecRecover":
        case "personal_sign":
        case "wallet_sign":
        case "personal_ecRecover":
        case "eth_signTransaction":
        case "eth_sendTransaction":
        case "eth_signTypedData_v1":
        case "eth_signTypedData_v3":
        case "eth_signTypedData_v4":
        case "eth_signTypedData":
        case "wallet_addEthereumChain":
        case "wallet_watchAsset":
        case "wallet_sendCalls":
        case "wallet_showCallsStatus":
        case "wallet_grantPermissions":
          return this.sendRequestToPopup(e);
        default:
          if (!this.chain.rpcUrl) throw v.rpc.internal("No RPC URL set for chain");
          return lt(e, this.chain.rpcUrl);
      }
    }
    async sendRequestToPopup(e) {
      var n, s;
      await ((s = (n = this.communicator).waitForPopupLoaded) === null || s === void 0 ? void 0 : s.call(n));
      const i = await this.sendEncryptedRequest(e), o = (await this.decryptResponseMessage(i)).result;
      if ("error" in o) throw o.error;
      return o.value;
    }
    async cleanup() {
      var e, n;
      this.storage.clear(), await this.keyManager.clear(), this.accounts = [], this.chain = {
        id: (n = (e = this.metadata.appChainIds) === null || e === void 0 ? void 0 : e[0]) !== null && n !== void 0 ? n : 1
      };
    }
    async handleSwitchChainRequest(e) {
      var n;
      const s = e.params;
      if (!s || !(!((n = s[0]) === null || n === void 0) && n.chainId)) throw v.rpc.invalidParams();
      const i = me(s[0].chainId);
      if (this.updateChain(i)) return null;
      const o = await this.sendRequestToPopup(e);
      return o === null && this.updateChain(i), o;
    }
    async sendEncryptedRequest(e) {
      const n = await this.keyManager.getSharedSecret();
      if (!n) throw v.provider.unauthorized("No valid session found, try requestAccounts before other methods");
      const s = await Ns({
        action: e,
        chainId: this.chain.id
      }, n), i = await this.createRequestMessage({
        encrypted: s
      });
      return this.communicator.postRequestAndWaitForResponse(i);
    }
    async createRequestMessage(e) {
      const n = await dn("public", await this.keyManager.getOwnPublicKey());
      return {
        id: crypto.randomUUID(),
        sender: n,
        content: e,
        timestamp: /* @__PURE__ */ new Date()
      };
    }
    async decryptResponseMessage(e) {
      var n, s;
      const i = e.content;
      if ("failure" in i) throw i.failure;
      const r = await this.keyManager.getSharedSecret();
      if (!r) throw v.provider.unauthorized("Invalid session");
      const o = await Os(i.encrypted, r), a = (n = o.data) === null || n === void 0 ? void 0 : n.chains;
      if (a) {
        const d = Object.entries(a).map(([h, l]) => ({
          id: Number(h),
          rpcUrl: l
        }));
        this.storage.storeObject(Et, d), this.updateChain(this.chain.id, d);
      }
      const c = (s = o.data) === null || s === void 0 ? void 0 : s.capabilities;
      return c && this.storage.storeObject(Ct, c), o;
    }
    updateChain(e, n) {
      var s;
      const i = n ?? this.storage.loadObject(Et), r = i == null ? void 0 : i.find((o) => o.id === e);
      return r ? (r !== this.chain && (this.chain = r, this.storage.storeObject(kt, r), (s = this.callback) === null || s === void 0 || s.call(this, "chainChanged", Q(r.id))), true) : false;
    }
  }
  var I = {}, ee = {};
  Object.defineProperty(ee, "__esModule", {
    value: true
  });
  ee.anumber = Ye;
  ee.abytes = fn;
  ee.ahash = Vs;
  ee.aexists = Ks;
  ee.aoutput = Fs;
  function Ye(t) {
    if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
  }
  function qs(t) {
    return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
  }
  function fn(t, ...e) {
    if (!qs(t)) throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
  }
  function Vs(t) {
    if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    Ye(t.outputLen), Ye(t.blockLen);
  }
  function Ks(t, e = true) {
    if (t.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && t.finished) throw new Error("Hash#digest() has already been called");
  }
  function Fs(t, e) {
    fn(t);
    const n = e.outputLen;
    if (t.length < n) throw new Error("digestInto() expects output buffer of length at least " + n);
  }
  var y = {};
  Object.defineProperty(y, "__esModule", {
    value: true
  });
  y.add5L = y.add5H = y.add4H = y.add4L = y.add3H = y.add3L = y.rotlBL = y.rotlBH = y.rotlSL = y.rotlSH = y.rotr32L = y.rotr32H = y.rotrBL = y.rotrBH = y.rotrSL = y.rotrSH = y.shrSL = y.shrSH = y.toBig = void 0;
  y.fromBig = dt;
  y.split = pn;
  y.add = Ln;
  const Se = BigInt(2 ** 32 - 1), Je = BigInt(32);
  function dt(t, e = false) {
    return e ? {
      h: Number(t & Se),
      l: Number(t >> Je & Se)
    } : {
      h: Number(t >> Je & Se) | 0,
      l: Number(t & Se) | 0
    };
  }
  function pn(t, e = false) {
    let n = new Uint32Array(t.length), s = new Uint32Array(t.length);
    for (let i = 0; i < t.length; i++) {
      const { h: r, l: o } = dt(t[i], e);
      [n[i], s[i]] = [
        r,
        o
      ];
    }
    return [
      n,
      s
    ];
  }
  const gn = (t, e) => BigInt(t >>> 0) << Je | BigInt(e >>> 0);
  y.toBig = gn;
  const _n = (t, e, n) => t >>> n;
  y.shrSH = _n;
  const mn = (t, e, n) => t << 32 - n | e >>> n;
  y.shrSL = mn;
  const yn = (t, e, n) => t >>> n | e << 32 - n;
  y.rotrSH = yn;
  const bn = (t, e, n) => t << 32 - n | e >>> n;
  y.rotrSL = bn;
  const wn = (t, e, n) => t << 64 - n | e >>> n - 32;
  y.rotrBH = wn;
  const vn = (t, e, n) => t >>> n - 32 | e << 64 - n;
  y.rotrBL = vn;
  const kn = (t, e) => e;
  y.rotr32H = kn;
  const En = (t, e) => t;
  y.rotr32L = En;
  const Cn = (t, e, n) => t << n | e >>> 32 - n;
  y.rotlSH = Cn;
  const xn = (t, e, n) => e << n | t >>> 32 - n;
  y.rotlSL = xn;
  const Sn = (t, e, n) => e << n - 32 | t >>> 64 - n;
  y.rotlBH = Sn;
  const In = (t, e, n) => t << n - 32 | e >>> 64 - n;
  y.rotlBL = In;
  function Ln(t, e, n, s) {
    const i = (e >>> 0) + (s >>> 0);
    return {
      h: t + n + (i / 2 ** 32 | 0) | 0,
      l: i | 0
    };
  }
  const An = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0);
  y.add3L = An;
  const Mn = (t, e, n, s) => e + n + s + (t / 2 ** 32 | 0) | 0;
  y.add3H = Mn;
  const Pn = (t, e, n, s) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (s >>> 0);
  y.add4L = Pn;
  const Tn = (t, e, n, s, i) => e + n + s + i + (t / 2 ** 32 | 0) | 0;
  y.add4H = Tn;
  const Rn = (t, e, n, s, i) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (s >>> 0) + (i >>> 0);
  y.add5L = Rn;
  const Nn = (t, e, n, s, i, r) => e + n + s + i + r + (t / 2 ** 32 | 0) | 0;
  y.add5H = Nn;
  const $s = {
    fromBig: dt,
    split: pn,
    toBig: gn,
    shrSH: _n,
    shrSL: mn,
    rotrSH: yn,
    rotrSL: bn,
    rotrBH: wn,
    rotrBL: vn,
    rotr32H: kn,
    rotr32L: En,
    rotlSH: Cn,
    rotlSL: xn,
    rotlBH: Sn,
    rotlBL: In,
    add: Ln,
    add3L: An,
    add3H: Mn,
    add4L: Pn,
    add4H: Tn,
    add5H: Nn,
    add5L: Rn
  };
  y.default = $s;
  var On = {}, De = {};
  Object.defineProperty(De, "__esModule", {
    value: true
  });
  De.crypto = void 0;
  De.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  (function(t) {
    Object.defineProperty(t, "__esModule", {
      value: true
    }), t.Hash = t.nextTick = t.byteSwapIfBE = t.isLE = void 0, t.isBytes = s, t.u8 = i, t.u32 = r, t.createView = o, t.rotr = a, t.rotl = c, t.byteSwap = d, t.byteSwap32 = h, t.bytesToHex = p, t.hexToBytes = C, t.asyncLoop = b, t.utf8ToBytes = w, t.toBytes = k, t.concatBytes = U, t.checkOpts = ne, t.wrapConstructor = Ce, t.wrapConstructorWithOpts = oe, t.wrapXOFConstructorWithOpts = xe, t.randomBytes = ae;
    const e = De, n = ee;
    function s(u) {
      return u instanceof Uint8Array || ArrayBuffer.isView(u) && u.constructor.name === "Uint8Array";
    }
    function i(u) {
      return new Uint8Array(u.buffer, u.byteOffset, u.byteLength);
    }
    function r(u) {
      return new Uint32Array(u.buffer, u.byteOffset, Math.floor(u.byteLength / 4));
    }
    function o(u) {
      return new DataView(u.buffer, u.byteOffset, u.byteLength);
    }
    function a(u, _) {
      return u << 32 - _ | u >>> _;
    }
    function c(u, _) {
      return u << _ | u >>> 32 - _ >>> 0;
    }
    t.isLE = new Uint8Array(new Uint32Array([
      287454020
    ]).buffer)[0] === 68;
    function d(u) {
      return u << 24 & 4278190080 | u << 8 & 16711680 | u >>> 8 & 65280 | u >>> 24 & 255;
    }
    t.byteSwapIfBE = t.isLE ? (u) => u : (u) => d(u);
    function h(u) {
      for (let _ = 0; _ < u.length; _++) u[_] = d(u[_]);
    }
    const l = Array.from({
      length: 256
    }, (u, _) => _.toString(16).padStart(2, "0"));
    function p(u) {
      (0, n.abytes)(u);
      let _ = "";
      for (let x = 0; x < u.length; x++) _ += l[u[x]];
      return _;
    }
    const f = {
      _0: 48,
      _9: 57,
      A: 65,
      F: 70,
      a: 97,
      f: 102
    };
    function m(u) {
      if (u >= f._0 && u <= f._9) return u - f._0;
      if (u >= f.A && u <= f.F) return u - (f.A - 10);
      if (u >= f.a && u <= f.f) return u - (f.a - 10);
    }
    function C(u) {
      if (typeof u != "string") throw new Error("hex string expected, got " + typeof u);
      const _ = u.length, x = _ / 2;
      if (_ % 2) throw new Error("hex string expected, got unpadded hex of length " + _);
      const A = new Uint8Array(x);
      for (let R = 0, D = 0; R < x; R++, D += 2) {
        const mt = m(u.charCodeAt(D)), yt = m(u.charCodeAt(D + 1));
        if (mt === void 0 || yt === void 0) {
          const ys = u[D] + u[D + 1];
          throw new Error('hex string expected, got non-hex character "' + ys + '" at index ' + D);
        }
        A[R] = mt * 16 + yt;
      }
      return A;
    }
    const g = async () => {
    };
    t.nextTick = g;
    async function b(u, _, x) {
      let A = Date.now();
      for (let R = 0; R < u; R++) {
        x(R);
        const D = Date.now() - A;
        D >= 0 && D < _ || (await (0, t.nextTick)(), A += D);
      }
    }
    function w(u) {
      if (typeof u != "string") throw new Error("utf8ToBytes expected string, got " + typeof u);
      return new Uint8Array(new TextEncoder().encode(u));
    }
    function k(u) {
      return typeof u == "string" && (u = w(u)), (0, n.abytes)(u), u;
    }
    function U(...u) {
      let _ = 0;
      for (let A = 0; A < u.length; A++) {
        const R = u[A];
        (0, n.abytes)(R), _ += R.length;
      }
      const x = new Uint8Array(_);
      for (let A = 0, R = 0; A < u.length; A++) {
        const D = u[A];
        x.set(D, R), R += D.length;
      }
      return x;
    }
    class H {
      clone() {
        return this._cloneInto();
      }
    }
    t.Hash = H;
    function ne(u, _) {
      if (_ !== void 0 && {}.toString.call(_) !== "[object Object]") throw new Error("Options should be object or undefined");
      return Object.assign(u, _);
    }
    function Ce(u) {
      const _ = (A) => u().update(k(A)).digest(), x = u();
      return _.outputLen = x.outputLen, _.blockLen = x.blockLen, _.create = () => u(), _;
    }
    function oe(u) {
      const _ = (A, R) => u(R).update(k(A)).digest(), x = u({});
      return _.outputLen = x.outputLen, _.blockLen = x.blockLen, _.create = (A) => u(A), _;
    }
    function xe(u) {
      const _ = (A, R) => u(R).update(k(A)).digest(), x = u({});
      return _.outputLen = x.outputLen, _.blockLen = x.blockLen, _.create = (A) => u(A), _;
    }
    function ae(u = 32) {
      if (e.crypto && typeof e.crypto.getRandomValues == "function") return e.crypto.getRandomValues(new Uint8Array(u));
      if (e.crypto && typeof e.crypto.randomBytes == "function") return e.crypto.randomBytes(u);
      throw new Error("crypto.getRandomValues must be defined");
    }
  })(On);
  Object.defineProperty(I, "__esModule", {
    value: true
  });
  I.shake256 = I.shake128 = I.keccak_512 = I.keccak_384 = I.keccak_256 = I.keccak_224 = I.sha3_512 = I.sha3_384 = I.sha3_256 = I.sha3_224 = I.Keccak = void 0;
  I.keccakP = jn;
  const le = ee, we = y, F = On, Dn = [], Un = [], Hn = [], zs = BigInt(0), pe = BigInt(1), Zs = BigInt(2), Gs = BigInt(7), Ys = BigInt(256), Js = BigInt(113);
  for (let t = 0, e = pe, n = 1, s = 0; t < 24; t++) {
    [n, s] = [
      s,
      (2 * n + 3 * s) % 5
    ], Dn.push(2 * (5 * s + n)), Un.push((t + 1) * (t + 2) / 2 % 64);
    let i = zs;
    for (let r = 0; r < 7; r++) e = (e << pe ^ (e >> Gs) * Js) % Ys, e & Zs && (i ^= pe << (pe << BigInt(r)) - pe);
    Hn.push(i);
  }
  const [Qs, Xs] = (0, we.split)(Hn, true), xt = (t, e, n) => n > 32 ? (0, we.rotlBH)(t, e, n) : (0, we.rotlSH)(t, e, n), St = (t, e, n) => n > 32 ? (0, we.rotlBL)(t, e, n) : (0, we.rotlSL)(t, e, n);
  function jn(t, e = 24) {
    const n = new Uint32Array(10);
    for (let s = 24 - e; s < 24; s++) {
      for (let o = 0; o < 10; o++) n[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
      for (let o = 0; o < 10; o += 2) {
        const a = (o + 8) % 10, c = (o + 2) % 10, d = n[c], h = n[c + 1], l = xt(d, h, 1) ^ n[a], p = St(d, h, 1) ^ n[a + 1];
        for (let f = 0; f < 50; f += 10) t[o + f] ^= l, t[o + f + 1] ^= p;
      }
      let i = t[2], r = t[3];
      for (let o = 0; o < 24; o++) {
        const a = Un[o], c = xt(i, r, a), d = St(i, r, a), h = Dn[o];
        i = t[h], r = t[h + 1], t[h] = c, t[h + 1] = d;
      }
      for (let o = 0; o < 50; o += 10) {
        for (let a = 0; a < 10; a++) n[a] = t[o + a];
        for (let a = 0; a < 10; a++) t[o + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10];
      }
      t[0] ^= Qs[s], t[1] ^= Xs[s];
    }
    n.fill(0);
  }
  class Ee extends F.Hash {
    constructor(e, n, s, i = false, r = 24) {
      if (super(), this.blockLen = e, this.suffix = n, this.outputLen = s, this.enableXOF = i, this.rounds = r, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, (0, le.anumber)(s), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200), this.state32 = (0, F.u32)(this.state);
    }
    keccak() {
      F.isLE || (0, F.byteSwap32)(this.state32), jn(this.state32, this.rounds), F.isLE || (0, F.byteSwap32)(this.state32), this.posOut = 0, this.pos = 0;
    }
    update(e) {
      (0, le.aexists)(this);
      const { blockLen: n, state: s } = this;
      e = (0, F.toBytes)(e);
      const i = e.length;
      for (let r = 0; r < i; ) {
        const o = Math.min(n - this.pos, i - r);
        for (let a = 0; a < o; a++) s[this.pos++] ^= e[r++];
        this.pos === n && this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished) return;
      this.finished = true;
      const { state: e, suffix: n, pos: s, blockLen: i } = this;
      e[s] ^= n, n & 128 && s === i - 1 && this.keccak(), e[i - 1] ^= 128, this.keccak();
    }
    writeInto(e) {
      (0, le.aexists)(this, false), (0, le.abytes)(e), this.finish();
      const n = this.state, { blockLen: s } = this;
      for (let i = 0, r = e.length; i < r; ) {
        this.posOut >= s && this.keccak();
        const o = Math.min(s - this.posOut, r - i);
        e.set(n.subarray(this.posOut, this.posOut + o), i), this.posOut += o, i += o;
      }
      return e;
    }
    xofInto(e) {
      if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
      return this.writeInto(e);
    }
    xof(e) {
      return (0, le.anumber)(e), this.xofInto(new Uint8Array(e));
    }
    digestInto(e) {
      if ((0, le.aoutput)(e, this), this.finished) throw new Error("digest() was already called");
      return this.writeInto(e), this.destroy(), e;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true, this.state.fill(0);
    }
    _cloneInto(e) {
      const { blockLen: n, suffix: s, outputLen: i, rounds: r, enableXOF: o } = this;
      return e || (e = new Ee(n, s, i, o, r)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = r, e.suffix = s, e.outputLen = i, e.enableXOF = o, e.destroyed = this.destroyed, e;
    }
  }
  I.Keccak = Ee;
  const te = (t, e, n) => (0, F.wrapConstructor)(() => new Ee(e, t, n));
  I.sha3_224 = te(6, 144, 224 / 8);
  I.sha3_256 = te(6, 136, 256 / 8);
  I.sha3_384 = te(6, 104, 384 / 8);
  I.sha3_512 = te(6, 72, 512 / 8);
  I.keccak_224 = te(1, 144, 224 / 8);
  I.keccak_256 = te(1, 136, 256 / 8);
  I.keccak_384 = te(1, 104, 384 / 8);
  I.keccak_512 = te(1, 72, 512 / 8);
  const Bn = (t, e, n) => (0, F.wrapXOFConstructorWithOpts)((s = {}) => new Ee(e, t, s.dkLen === void 0 ? n : s.dkLen, true));
  I.shake128 = Bn(31, 168, 128 / 8);
  I.shake256 = Bn(31, 136, 256 / 8);
  const { keccak_256: ei } = I;
  function Wn(t) {
    return S.allocUnsafe(t).fill(0);
  }
  function ti(t) {
    return t.toString(2).length;
  }
  function qn(t, e) {
    let n = t.toString(16);
    n.length % 2 !== 0 && (n = "0" + n);
    const s = n.match(/.{1,2}/g).map((i) => parseInt(i, 16));
    for (; s.length < e; ) s.unshift(0);
    return S.from(s);
  }
  function ni(t, e) {
    const n = t < 0n;
    let s;
    if (n) {
      const i = (1n << BigInt(e)) - 1n;
      s = (~t & i) + 1n;
    } else s = t;
    return s &= (1n << BigInt(e)) - 1n, s;
  }
  function Vn(t, e, n) {
    const s = Wn(e);
    return t = Ue(t), n ? t.length < e ? (t.copy(s), s) : t.slice(0, e) : t.length < e ? (t.copy(s, e - t.length), s) : t.slice(-e);
  }
  function si(t, e) {
    return Vn(t, e, true);
  }
  function Ue(t) {
    if (!S.isBuffer(t)) if (Array.isArray(t)) t = S.from(t);
    else if (typeof t == "string") Kn(t) ? t = S.from(oi(Fn(t)), "hex") : t = S.from(t);
    else if (typeof t == "number") t = intToBuffer(t);
    else if (t == null) t = S.allocUnsafe(0);
    else if (typeof t == "bigint") t = qn(t);
    else if (t.toArray) t = S.from(t.toArray());
    else throw new Error("invalid type");
    return t;
  }
  function ii(t) {
    return t = Ue(t), "0x" + t.toString("hex");
  }
  function ri(t, e) {
    if (t = Ue(t), e || (e = 256), e !== 256) throw new Error("unsupported");
    return S.from(ei(new Uint8Array(t)));
  }
  function oi(t) {
    return t.length % 2 ? "0" + t : t;
  }
  function Kn(t) {
    return typeof t == "string" && t.match(/^0x[0-9A-Fa-f]*$/);
  }
  function Fn(t) {
    return typeof t == "string" && t.startsWith("0x") ? t.slice(2) : t;
  }
  var $n = {
    zeros: Wn,
    setLength: Vn,
    setLengthRight: si,
    isHexString: Kn,
    stripHexPrefix: Fn,
    toBuffer: Ue,
    bufferToHex: ii,
    keccak: ri,
    bitLengthFromBigInt: ti,
    bufferBEFromBigInt: qn,
    twosFromBigInt: ni
  };
  const O = $n;
  function zn(t) {
    return t.startsWith("int[") ? "int256" + t.slice(3) : t === "int" ? "int256" : t.startsWith("uint[") ? "uint256" + t.slice(4) : t === "uint" ? "uint256" : t.startsWith("fixed[") ? "fixed128x128" + t.slice(5) : t === "fixed" ? "fixed128x128" : t.startsWith("ufixed[") ? "ufixed128x128" + t.slice(6) : t === "ufixed" ? "ufixed128x128" : t;
  }
  function de(t) {
    return Number.parseInt(/^\D+(\d+)$/.exec(t)[1], 10);
  }
  function It(t) {
    var e = /^\D+(\d+)x(\d+)$/.exec(t);
    return [
      Number.parseInt(e[1], 10),
      Number.parseInt(e[2], 10)
    ];
  }
  function Zn(t) {
    var e = t.match(/(.*)\[(.*?)\]$/);
    return e ? e[2] === "" ? "dynamic" : Number.parseInt(e[2], 10) : null;
  }
  function ie(t) {
    var e = typeof t;
    if (e === "string" || e === "number") return BigInt(t);
    if (e === "bigint") return t;
    throw new Error("Argument is not a number");
  }
  function V(t, e) {
    var n, s, i, r;
    if (t === "address") return V("uint160", ie(e));
    if (t === "bool") return V("uint8", e ? 1 : 0);
    if (t === "string") return V("bytes", new S(e, "utf8"));
    if (ci(t)) {
      if (typeof e.length > "u") throw new Error("Not an array?");
      if (n = Zn(t), n !== "dynamic" && n !== 0 && e.length > n) throw new Error("Elements exceed array size: " + n);
      i = [], t = t.slice(0, t.lastIndexOf("[")), typeof e == "string" && (e = JSON.parse(e));
      for (r in e) i.push(V(t, e[r]));
      if (n === "dynamic") {
        var o = V("uint256", e.length);
        i.unshift(o);
      }
      return S.concat(i);
    } else {
      if (t === "bytes") return e = new S(e), i = S.concat([
        V("uint256", e.length),
        e
      ]), e.length % 32 !== 0 && (i = S.concat([
        i,
        O.zeros(32 - e.length % 32)
      ])), i;
      if (t.startsWith("bytes")) {
        if (n = de(t), n < 1 || n > 32) throw new Error("Invalid bytes<N> width: " + n);
        return O.setLengthRight(e, 32);
      } else if (t.startsWith("uint")) {
        if (n = de(t), n % 8 || n < 8 || n > 256) throw new Error("Invalid uint<N> width: " + n);
        s = ie(e);
        const a = O.bitLengthFromBigInt(s);
        if (a > n) throw new Error("Supplied uint exceeds width: " + n + " vs " + a);
        if (s < 0) throw new Error("Supplied uint is negative");
        return O.bufferBEFromBigInt(s, 32);
      } else if (t.startsWith("int")) {
        if (n = de(t), n % 8 || n < 8 || n > 256) throw new Error("Invalid int<N> width: " + n);
        s = ie(e);
        const a = O.bitLengthFromBigInt(s);
        if (a > n) throw new Error("Supplied int exceeds width: " + n + " vs " + a);
        const c = O.twosFromBigInt(s, 256);
        return O.bufferBEFromBigInt(c, 32);
      } else if (t.startsWith("ufixed")) {
        if (n = It(t), s = ie(e), s < 0) throw new Error("Supplied ufixed is negative");
        return V("uint256", s * BigInt(2) ** BigInt(n[1]));
      } else if (t.startsWith("fixed")) return n = It(t), V("int256", ie(e) * BigInt(2) ** BigInt(n[1]));
    }
    throw new Error("Unsupported or invalid type: " + t);
  }
  function ai(t) {
    return t === "string" || t === "bytes" || Zn(t) === "dynamic";
  }
  function ci(t) {
    return t.lastIndexOf("]") === t.length - 1;
  }
  function li(t, e) {
    var n = [], s = [], i = 32 * t.length;
    for (var r in t) {
      var o = zn(t[r]), a = e[r], c = V(o, a);
      ai(o) ? (n.push(V("uint256", i)), s.push(c), i += c.length) : n.push(c);
    }
    return S.concat(n.concat(s));
  }
  function Gn(t, e) {
    if (t.length !== e.length) throw new Error("Number of types are not matching the values");
    for (var n, s, i = [], r = 0; r < t.length; r++) {
      var o = zn(t[r]), a = e[r];
      if (o === "bytes") i.push(a);
      else if (o === "string") i.push(new S(a, "utf8"));
      else if (o === "bool") i.push(new S(a ? "01" : "00", "hex"));
      else if (o === "address") i.push(O.setLength(a, 20));
      else if (o.startsWith("bytes")) {
        if (n = de(o), n < 1 || n > 32) throw new Error("Invalid bytes<N> width: " + n);
        i.push(O.setLengthRight(a, n));
      } else if (o.startsWith("uint")) {
        if (n = de(o), n % 8 || n < 8 || n > 256) throw new Error("Invalid uint<N> width: " + n);
        s = ie(a);
        const c = O.bitLengthFromBigInt(s);
        if (c > n) throw new Error("Supplied uint exceeds width: " + n + " vs " + c);
        i.push(O.bufferBEFromBigInt(s, n / 8));
      } else if (o.startsWith("int")) {
        if (n = de(o), n % 8 || n < 8 || n > 256) throw new Error("Invalid int<N> width: " + n);
        s = ie(a);
        const c = O.bitLengthFromBigInt(s);
        if (c > n) throw new Error("Supplied int exceeds width: " + n + " vs " + c);
        const d = O.twosFromBigInt(s, n);
        i.push(O.bufferBEFromBigInt(d, n / 8));
      } else throw new Error("Unsupported or invalid type: " + o);
    }
    return S.concat(i);
  }
  function di(t, e) {
    return O.keccak(Gn(t, e));
  }
  var hi = {
    rawEncode: li,
    solidityPack: Gn,
    soliditySHA3: di
  };
  const B = $n, ye = hi, Yn = {
    type: "object",
    properties: {
      types: {
        type: "object",
        additionalProperties: {
          type: "array",
          items: {
            type: "object",
            properties: {
              name: {
                type: "string"
              },
              type: {
                type: "string"
              }
            },
            required: [
              "name",
              "type"
            ]
          }
        }
      },
      primaryType: {
        type: "string"
      },
      domain: {
        type: "object"
      },
      message: {
        type: "object"
      }
    },
    required: [
      "types",
      "primaryType",
      "domain",
      "message"
    ]
  }, Ke = {
    encodeData(t, e, n, s = true) {
      const i = [
        "bytes32"
      ], r = [
        this.hashType(t, n)
      ];
      if (s) {
        const o = (a, c, d) => {
          if (n[c] !== void 0) return [
            "bytes32",
            d == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : B.keccak(this.encodeData(c, d, n, s))
          ];
          if (d === void 0) throw new Error(`missing value for field ${a} of type ${c}`);
          if (c === "bytes") return [
            "bytes32",
            B.keccak(d)
          ];
          if (c === "string") return typeof d == "string" && (d = S.from(d, "utf8")), [
            "bytes32",
            B.keccak(d)
          ];
          if (c.lastIndexOf("]") === c.length - 1) {
            const h = c.slice(0, c.lastIndexOf("[")), l = d.map((p) => o(a, h, p));
            return [
              "bytes32",
              B.keccak(ye.rawEncode(l.map(([p]) => p), l.map(([, p]) => p)))
            ];
          }
          return [
            c,
            d
          ];
        };
        for (const a of n[t]) {
          const [c, d] = o(a.name, a.type, e[a.name]);
          i.push(c), r.push(d);
        }
      } else for (const o of n[t]) {
        let a = e[o.name];
        if (a !== void 0) if (o.type === "bytes") i.push("bytes32"), a = B.keccak(a), r.push(a);
        else if (o.type === "string") i.push("bytes32"), typeof a == "string" && (a = S.from(a, "utf8")), a = B.keccak(a), r.push(a);
        else if (n[o.type] !== void 0) i.push("bytes32"), a = B.keccak(this.encodeData(o.type, a, n, s)), r.push(a);
        else {
          if (o.type.lastIndexOf("]") === o.type.length - 1) throw new Error("Arrays currently unimplemented in encodeData");
          i.push(o.type), r.push(a);
        }
      }
      return ye.rawEncode(i, r);
    },
    encodeType(t, e) {
      let n = "", s = this.findTypeDependencies(t, e).filter((i) => i !== t);
      s = [
        t
      ].concat(s.sort());
      for (const i of s) {
        if (!e[i]) throw new Error("No type definition specified: " + i);
        n += i + "(" + e[i].map(({ name: o, type: a }) => a + " " + o).join(",") + ")";
      }
      return n;
    },
    findTypeDependencies(t, e, n = []) {
      if (t = t.match(/^\w*/)[0], n.includes(t) || e[t] === void 0) return n;
      n.push(t);
      for (const s of e[t]) for (const i of this.findTypeDependencies(s.type, e, n)) !n.includes(i) && n.push(i);
      return n;
    },
    hashStruct(t, e, n, s = true) {
      return B.keccak(this.encodeData(t, e, n, s));
    },
    hashType(t, e) {
      return B.keccak(this.encodeType(t, e));
    },
    sanitizeData(t) {
      const e = {};
      for (const n in Yn.properties) t[n] && (e[n] = t[n]);
      return e.types && (e.types = Object.assign({
        EIP712Domain: []
      }, e.types)), e;
    },
    hash(t, e = true) {
      const n = this.sanitizeData(t), s = [
        S.from("1901", "hex")
      ];
      return s.push(this.hashStruct("EIP712Domain", n.domain, n.types, e)), n.primaryType !== "EIP712Domain" && s.push(this.hashStruct(n.primaryType, n.message, n.types, e)), B.keccak(S.concat(s));
    }
  };
  var ui = {
    TYPED_MESSAGE_SCHEMA: Yn,
    TypedDataUtils: Ke,
    hashForSignTypedDataLegacy: function(t) {
      return fi(t.data);
    },
    hashForSignTypedData_v3: function(t) {
      return Ke.hash(t.data, false);
    },
    hashForSignTypedData_v4: function(t) {
      return Ke.hash(t.data);
    }
  };
  function fi(t) {
    const e = new Error("Expect argument to be non-empty array");
    if (typeof t != "object" || !t.length) throw e;
    const n = t.map(function(r) {
      return r.type === "bytes" ? B.toBuffer(r.value) : r.value;
    }), s = t.map(function(r) {
      return r.type;
    }), i = t.map(function(r) {
      if (!r.name) throw e;
      return r.type + " " + r.name;
    });
    return ye.soliditySHA3([
      "bytes32",
      "bytes32"
    ], [
      ye.soliditySHA3(new Array(t.length).fill("string"), i),
      ye.soliditySHA3(s, n)
    ]);
  }
  const Ie = Qt(ui), pi = "walletUsername", Qe = "Addresses", gi = "AppVersion";
  function N(t) {
    return t.errorMessage !== void 0;
  }
  class _i {
    constructor(e) {
      this.secret = e;
    }
    async encrypt(e) {
      const n = this.secret;
      if (n.length !== 64) throw Error("secret must be 256 bits");
      const s = crypto.getRandomValues(new Uint8Array(12)), i = await crypto.subtle.importKey("raw", Ae(n), {
        name: "aes-gcm"
      }, false, [
        "encrypt",
        "decrypt"
      ]), r = new TextEncoder(), o = await window.crypto.subtle.encrypt({
        name: "AES-GCM",
        iv: s
      }, i, r.encode(e)), a = 16, c = o.slice(o.byteLength - a), d = o.slice(0, o.byteLength - a), h = new Uint8Array(c), l = new Uint8Array(d), p = new Uint8Array([
        ...s,
        ...h,
        ...l
      ]);
      return ot(p);
    }
    async decrypt(e) {
      const n = this.secret;
      if (n.length !== 64) throw Error("secret must be 256 bits");
      return new Promise((s, i) => {
        (async function() {
          const r = await crypto.subtle.importKey("raw", Ae(n), {
            name: "aes-gcm"
          }, false, [
            "encrypt",
            "decrypt"
          ]), o = Ae(e), a = o.slice(0, 12), c = o.slice(12, 28), d = o.slice(28), h = new Uint8Array([
            ...d,
            ...c
          ]), l = {
            name: "AES-GCM",
            iv: new Uint8Array(a)
          };
          try {
            const p = await window.crypto.subtle.decrypt(l, r, h), f = new TextDecoder();
            s(f.decode(p));
          } catch (p) {
            i(p);
          }
        })();
      });
    }
  }
  class mi {
    constructor(e, n, s) {
      this.linkAPIUrl = e, this.sessionId = n;
      const i = `${n}:${s}`;
      this.auth = `Basic ${btoa(i)}`;
    }
    async markUnseenEventsAsSeen(e) {
      return Promise.all(e.map((n) => fetch(`${this.linkAPIUrl}/events/${n.eventId}/seen`, {
        method: "POST",
        headers: {
          Authorization: this.auth
        }
      }))).catch((n) => console.error("Unabled to mark event as failed:", n));
    }
    async fetchUnseenEvents() {
      var e;
      const n = await fetch(`${this.linkAPIUrl}/events?unseen=true`, {
        headers: {
          Authorization: this.auth
        }
      });
      if (n.ok) {
        const { events: s, error: i } = await n.json();
        if (i) throw new Error(`Check unseen events failed: ${i}`);
        const r = (e = s == null ? void 0 : s.filter((o) => o.event === "Web3Response").map((o) => ({
          type: "Event",
          sessionId: this.sessionId,
          eventId: o.id,
          event: o.event,
          data: o.data
        }))) !== null && e !== void 0 ? e : [];
        return this.markUnseenEventsAsSeen(r), r;
      }
      throw new Error(`Check unseen events failed: ${n.status}`);
    }
  }
  var Z;
  (function(t) {
    t[t.DISCONNECTED = 0] = "DISCONNECTED", t[t.CONNECTING = 1] = "CONNECTING", t[t.CONNECTED = 2] = "CONNECTED";
  })(Z || (Z = {}));
  class yi {
    setConnectionStateListener(e) {
      this.connectionStateListener = e;
    }
    setIncomingDataListener(e) {
      this.incomingDataListener = e;
    }
    constructor(e, n = WebSocket) {
      this.WebSocketClass = n, this.webSocket = null, this.pendingData = [], this.url = e.replace(/^http/, "ws");
    }
    async connect() {
      if (this.webSocket) throw new Error("webSocket object is not null");
      return new Promise((e, n) => {
        var s;
        let i;
        try {
          this.webSocket = i = new this.WebSocketClass(this.url);
        } catch (r) {
          n(r);
          return;
        }
        (s = this.connectionStateListener) === null || s === void 0 || s.call(this, Z.CONNECTING), i.onclose = (r) => {
          var o;
          this.clearWebSocket(), n(new Error(`websocket error ${r.code}: ${r.reason}`)), (o = this.connectionStateListener) === null || o === void 0 || o.call(this, Z.DISCONNECTED);
        }, i.onopen = (r) => {
          var o;
          e(), (o = this.connectionStateListener) === null || o === void 0 || o.call(this, Z.CONNECTED), this.pendingData.length > 0 && ([
            ...this.pendingData
          ].forEach((c) => this.sendData(c)), this.pendingData = []);
        }, i.onmessage = (r) => {
          var o, a;
          if (r.data === "h") (o = this.incomingDataListener) === null || o === void 0 || o.call(this, {
            type: "Heartbeat"
          });
          else try {
            const c = JSON.parse(r.data);
            (a = this.incomingDataListener) === null || a === void 0 || a.call(this, c);
          } catch {
          }
        };
      });
    }
    disconnect() {
      var e;
      const { webSocket: n } = this;
      if (n) {
        this.clearWebSocket(), (e = this.connectionStateListener) === null || e === void 0 || e.call(this, Z.DISCONNECTED), this.connectionStateListener = void 0, this.incomingDataListener = void 0;
        try {
          n.close();
        } catch {
        }
      }
    }
    sendData(e) {
      const { webSocket: n } = this;
      if (!n) {
        this.pendingData.push(e), this.connect();
        return;
      }
      n.send(e);
    }
    clearWebSocket() {
      const { webSocket: e } = this;
      e && (this.webSocket = null, e.onclose = null, e.onerror = null, e.onmessage = null, e.onopen = null);
    }
  }
  const Lt = 1e4, bi = 6e4;
  class wi {
    constructor({ session: e, linkAPIUrl: n, listener: s }) {
      this.destroyed = false, this.lastHeartbeatResponse = 0, this.nextReqId = $(1), this._connected = false, this._linked = false, this.shouldFetchUnseenEventsOnConnect = false, this.requestResolutions = /* @__PURE__ */ new Map(), this.handleSessionMetadataUpdated = (r) => {
        if (!r) return;
        (/* @__PURE__ */ new Map([
          [
            "__destroyed",
            this.handleDestroyed
          ],
          [
            "EthereumAddress",
            this.handleAccountUpdated
          ],
          [
            "WalletUsername",
            this.handleWalletUsernameUpdated
          ],
          [
            "AppVersion",
            this.handleAppVersionUpdated
          ],
          [
            "ChainId",
            (a) => r.JsonRpcUrl && this.handleChainUpdated(a, r.JsonRpcUrl)
          ]
        ])).forEach((a, c) => {
          const d = r[c];
          d !== void 0 && a(d);
        });
      }, this.handleDestroyed = (r) => {
        var o;
        r === "1" && ((o = this.listener) === null || o === void 0 || o.resetAndReload());
      }, this.handleAccountUpdated = async (r) => {
        var o;
        const a = await this.cipher.decrypt(r);
        (o = this.listener) === null || o === void 0 || o.accountUpdated(a);
      }, this.handleMetadataUpdated = async (r, o) => {
        var a;
        const c = await this.cipher.decrypt(o);
        (a = this.listener) === null || a === void 0 || a.metadataUpdated(r, c);
      }, this.handleWalletUsernameUpdated = async (r) => {
        this.handleMetadataUpdated(pi, r);
      }, this.handleAppVersionUpdated = async (r) => {
        this.handleMetadataUpdated(gi, r);
      }, this.handleChainUpdated = async (r, o) => {
        var a;
        const c = await this.cipher.decrypt(r), d = await this.cipher.decrypt(o);
        (a = this.listener) === null || a === void 0 || a.chainUpdated(c, d);
      }, this.session = e, this.cipher = new _i(e.secret), this.listener = s;
      const i = new yi(`${n}/rpc`, WebSocket);
      i.setConnectionStateListener(async (r) => {
        let o = false;
        switch (r) {
          case Z.DISCONNECTED:
            if (!this.destroyed) {
              const a = async () => {
                await new Promise((c) => setTimeout(c, 5e3)), this.destroyed || i.connect().catch(() => {
                  a();
                });
              };
              a();
            }
            break;
          case Z.CONNECTED:
            o = await this.handleConnected(), this.updateLastHeartbeat(), setInterval(() => {
              this.heartbeat();
            }, Lt), this.shouldFetchUnseenEventsOnConnect && this.fetchUnseenEventsAPI();
            break;
          case Z.CONNECTING:
            break;
        }
        this.connected !== o && (this.connected = o);
      }), i.setIncomingDataListener((r) => {
        var o;
        switch (r.type) {
          case "Heartbeat":
            this.updateLastHeartbeat();
            return;
          case "IsLinkedOK":
          case "Linked": {
            const a = r.type === "IsLinkedOK" ? r.linked : void 0;
            this.linked = a || r.onlineGuests > 0;
            break;
          }
          case "GetSessionConfigOK":
          case "SessionConfigUpdated": {
            this.handleSessionMetadataUpdated(r.metadata);
            break;
          }
          case "Event": {
            this.handleIncomingEvent(r);
            break;
          }
        }
        r.id !== void 0 && ((o = this.requestResolutions.get(r.id)) === null || o === void 0 || o(r));
      }), this.ws = i, this.http = new mi(n, e.id, e.key);
    }
    connect() {
      if (this.destroyed) throw new Error("instance is destroyed");
      this.ws.connect();
    }
    async destroy() {
      this.destroyed || (await this.makeRequest({
        type: "SetSessionConfig",
        id: $(this.nextReqId++),
        sessionId: this.session.id,
        metadata: {
          __destroyed: "1"
        }
      }, {
        timeout: 1e3
      }), this.destroyed = true, this.ws.disconnect(), this.listener = void 0);
    }
    get connected() {
      return this._connected;
    }
    set connected(e) {
      this._connected = e;
    }
    get linked() {
      return this._linked;
    }
    set linked(e) {
      var n, s;
      this._linked = e, e && ((n = this.onceLinked) === null || n === void 0 || n.call(this)), (s = this.listener) === null || s === void 0 || s.linkedUpdated(e);
    }
    setOnceLinked(e) {
      return new Promise((n) => {
        this.linked ? e().then(n) : this.onceLinked = () => {
          e().then(n), this.onceLinked = void 0;
        };
      });
    }
    async handleIncomingEvent(e) {
      var n;
      if (e.type !== "Event" || e.event !== "Web3Response") return;
      const s = await this.cipher.decrypt(e.data), i = JSON.parse(s);
      if (i.type !== "WEB3_RESPONSE") return;
      const { id: r, response: o } = i;
      (n = this.listener) === null || n === void 0 || n.handleWeb3ResponseMessage(r, o);
    }
    async checkUnseenEvents() {
      if (!this.connected) {
        this.shouldFetchUnseenEventsOnConnect = true;
        return;
      }
      await new Promise((e) => setTimeout(e, 250));
      try {
        await this.fetchUnseenEventsAPI();
      } catch (e) {
        console.error("Unable to check for unseen events", e);
      }
    }
    async fetchUnseenEventsAPI() {
      this.shouldFetchUnseenEventsOnConnect = false, (await this.http.fetchUnseenEvents()).forEach((n) => this.handleIncomingEvent(n));
    }
    async publishEvent(e, n, s = false) {
      const i = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, n), {
        origin: location.origin,
        location: location.href,
        relaySource: "coinbaseWalletExtension" in window && window.coinbaseWalletExtension ? "injected_sdk" : "sdk"
      }))), r = {
        type: "PublishEvent",
        id: $(this.nextReqId++),
        sessionId: this.session.id,
        event: e,
        data: i,
        callWebhook: s
      };
      return this.setOnceLinked(async () => {
        const o = await this.makeRequest(r);
        if (o.type === "Fail") throw new Error(o.error || "failed to publish event");
        return o.eventId;
      });
    }
    sendData(e) {
      this.ws.sendData(JSON.stringify(e));
    }
    updateLastHeartbeat() {
      this.lastHeartbeatResponse = Date.now();
    }
    heartbeat() {
      if (Date.now() - this.lastHeartbeatResponse > Lt * 2) {
        this.ws.disconnect();
        return;
      }
      try {
        this.ws.sendData("h");
      } catch {
      }
    }
    async makeRequest(e, n = {
      timeout: bi
    }) {
      const s = e.id;
      this.sendData(e);
      let i;
      return Promise.race([
        new Promise((r, o) => {
          i = window.setTimeout(() => {
            o(new Error(`request ${s} timed out`));
          }, n.timeout);
        }),
        new Promise((r) => {
          this.requestResolutions.set(s, (o) => {
            clearTimeout(i), r(o), this.requestResolutions.delete(s);
          });
        })
      ]);
    }
    async handleConnected() {
      return (await this.makeRequest({
        type: "HostSession",
        id: $(this.nextReqId++),
        sessionId: this.session.id,
        sessionKey: this.session.key
      })).type === "Fail" ? false : (this.sendData({
        type: "IsLinked",
        id: $(this.nextReqId++),
        sessionId: this.session.id
      }), this.sendData({
        type: "GetSessionConfig",
        id: $(this.nextReqId++),
        sessionId: this.session.id
      }), true);
    }
  }
  class vi {
    constructor() {
      this._nextRequestId = 0, this.callbacks = /* @__PURE__ */ new Map();
    }
    makeRequestId() {
      this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
      const e = this._nextRequestId, n = cn(e.toString(16));
      return this.callbacks.get(n) && this.callbacks.delete(n), e;
    }
  }
  function ki(t) {
    return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
  }
  function ht(t, ...e) {
    if (!ki(t)) throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
  }
  function At(t, e = true) {
    if (t.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && t.finished) throw new Error("Hash#digest() has already been called");
  }
  function Ei(t, e) {
    ht(t);
    const n = e.outputLen;
    if (t.length < n) throw new Error("digestInto() expects output buffer of length at least " + n);
  }
  function Fe(t) {
    return new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  function q(t, e) {
    return t << 32 - e | t >>> e;
  }
  const Ci = Array.from({
    length: 256
  }, (t, e) => e.toString(16).padStart(2, "0"));
  function xi(t) {
    ht(t);
    let e = "";
    for (let n = 0; n < t.length; n++) e += Ci[t[n]];
    return e;
  }
  function Si(t) {
    if (typeof t != "string") throw new Error("utf8ToBytes expected string, got " + typeof t);
    return new Uint8Array(new TextEncoder().encode(t));
  }
  function Jn(t) {
    return typeof t == "string" && (t = Si(t)), ht(t), t;
  }
  class Ii {
    clone() {
      return this._cloneInto();
    }
  }
  function Li(t) {
    const e = (s) => t().update(Jn(s)).digest(), n = t();
    return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e;
  }
  function Ai(t, e, n, s) {
    if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n, s);
    const i = BigInt(32), r = BigInt(4294967295), o = Number(n >> i & r), a = Number(n & r), c = s ? 4 : 0, d = s ? 0 : 4;
    t.setUint32(e + c, o, s), t.setUint32(e + d, a, s);
  }
  function Mi(t, e, n) {
    return t & e ^ ~t & n;
  }
  function Pi(t, e, n) {
    return t & e ^ t & n ^ e & n;
  }
  class Ti extends Ii {
    constructor(e, n, s, i) {
      super(), this.blockLen = e, this.outputLen = n, this.padOffset = s, this.isLE = i, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e), this.view = Fe(this.buffer);
    }
    update(e) {
      At(this);
      const { view: n, buffer: s, blockLen: i } = this;
      e = Jn(e);
      const r = e.length;
      for (let o = 0; o < r; ) {
        const a = Math.min(i - this.pos, r - o);
        if (a === i) {
          const c = Fe(e);
          for (; i <= r - o; o += i) this.process(c, o);
          continue;
        }
        s.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(n, 0), this.pos = 0);
      }
      return this.length += e.length, this.roundClean(), this;
    }
    digestInto(e) {
      At(this), Ei(e, this), this.finished = true;
      const { buffer: n, view: s, blockLen: i, isLE: r } = this;
      let { pos: o } = this;
      n[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(s, 0), o = 0);
      for (let l = o; l < i; l++) n[l] = 0;
      Ai(s, i - 8, BigInt(this.length * 8), r), this.process(s, 0);
      const a = Fe(e), c = this.outputLen;
      if (c % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
      const d = c / 4, h = this.get();
      if (d > h.length) throw new Error("_sha2: outputLen bigger than state");
      for (let l = 0; l < d; l++) a.setUint32(4 * l, h[l], r);
    }
    digest() {
      const { buffer: e, outputLen: n } = this;
      this.digestInto(e);
      const s = e.slice(0, n);
      return this.destroy(), s;
    }
    _cloneInto(e) {
      e || (e = new this.constructor()), e.set(...this.get());
      const { blockLen: n, buffer: s, length: i, finished: r, destroyed: o, pos: a } = this;
      return e.length = i, e.pos = a, e.finished = r, e.destroyed = o, i % n && e.buffer.set(s), e;
    }
  }
  const Ri = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]), Y = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]), J = new Uint32Array(64);
  class Ni extends Ti {
    constructor() {
      super(64, 32, 8, false), this.A = Y[0] | 0, this.B = Y[1] | 0, this.C = Y[2] | 0, this.D = Y[3] | 0, this.E = Y[4] | 0, this.F = Y[5] | 0, this.G = Y[6] | 0, this.H = Y[7] | 0;
    }
    get() {
      const { A: e, B: n, C: s, D: i, E: r, F: o, G: a, H: c } = this;
      return [
        e,
        n,
        s,
        i,
        r,
        o,
        a,
        c
      ];
    }
    set(e, n, s, i, r, o, a, c) {
      this.A = e | 0, this.B = n | 0, this.C = s | 0, this.D = i | 0, this.E = r | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;
    }
    process(e, n) {
      for (let l = 0; l < 16; l++, n += 4) J[l] = e.getUint32(n, false);
      for (let l = 16; l < 64; l++) {
        const p = J[l - 15], f = J[l - 2], m = q(p, 7) ^ q(p, 18) ^ p >>> 3, C = q(f, 17) ^ q(f, 19) ^ f >>> 10;
        J[l] = C + J[l - 7] + m + J[l - 16] | 0;
      }
      let { A: s, B: i, C: r, D: o, E: a, F: c, G: d, H: h } = this;
      for (let l = 0; l < 64; l++) {
        const p = q(a, 6) ^ q(a, 11) ^ q(a, 25), f = h + p + Mi(a, c, d) + Ri[l] + J[l] | 0, C = (q(s, 2) ^ q(s, 13) ^ q(s, 22)) + Pi(s, i, r) | 0;
        h = d, d = c, c = a, a = o + f | 0, o = r, r = i, i = s, s = f + C | 0;
      }
      s = s + this.A | 0, i = i + this.B | 0, r = r + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, d = d + this.G | 0, h = h + this.H | 0, this.set(s, i, r, o, a, c, d, h);
    }
    roundClean() {
      J.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
  }
  const Oi = Li(() => new Ni()), Mt = "session:id", Pt = "session:secret", Tt = "session:linked";
  class he {
    constructor(e, n, s, i = false) {
      this.storage = e, this.id = n, this.secret = s, this.key = xi(Oi(`${n}, ${s} WalletLink`)), this._linked = !!i;
    }
    static create(e) {
      const n = se(16), s = se(32);
      return new he(e, n, s).save();
    }
    static load(e) {
      const n = e.getItem(Mt), s = e.getItem(Tt), i = e.getItem(Pt);
      return n && i ? new he(e, n, i, s === "1") : null;
    }
    get linked() {
      return this._linked;
    }
    set linked(e) {
      this._linked = e, this.persistLinked();
    }
    save() {
      return this.storage.setItem(Mt, this.id), this.storage.setItem(Pt, this.secret), this.persistLinked(), this;
    }
    persistLinked() {
      this.storage.setItem(Tt, this._linked ? "1" : "0");
    }
  }
  function Di() {
    try {
      return window.frameElement !== null;
    } catch {
      return false;
    }
  }
  function Ui() {
    try {
      return Di() && window.top ? window.top.location : window.location;
    } catch {
      return window.location;
    }
  }
  function Hi() {
    var t;
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test((t = window == null ? void 0 : window.navigator) === null || t === void 0 ? void 0 : t.userAgent);
  }
  function Qn() {
    var t, e;
    return (e = (t = window == null ? void 0 : window.matchMedia) === null || t === void 0 ? void 0 : t.call(window, "(prefers-color-scheme: dark)").matches) !== null && e !== void 0 ? e : false;
  }
  const ji = '@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}';
  function Xn() {
    const t = document.createElement("style");
    t.type = "text/css", t.appendChild(document.createTextNode(ji)), document.documentElement.appendChild(t);
  }
  var He, L, es, re, Rt, ts, ns, ss, ut, Xe, et, ve = {}, is = [], Bi = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, ft = Array.isArray;
  function X(t, e) {
    for (var n in e) t[n] = e[n];
    return t;
  }
  function pt(t) {
    t && t.parentNode && t.parentNode.removeChild(t);
  }
  function E(t, e, n) {
    var s, i, r, o = {};
    for (r in e) r == "key" ? s = e[r] : r == "ref" ? i = e[r] : o[r] = e[r];
    if (arguments.length > 2 && (o.children = arguments.length > 3 ? He.call(arguments, 2) : n), typeof t == "function" && t.defaultProps != null) for (r in t.defaultProps) o[r] === void 0 && (o[r] = t.defaultProps[r]);
    return Me(t, o, s, i, null);
  }
  function Me(t, e, n, s, i) {
    var r = {
      type: t,
      props: e,
      key: n,
      ref: s,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __c: null,
      constructor: void 0,
      __v: i ?? ++es,
      __i: -1,
      __u: 0
    };
    return i == null && L.vnode != null && L.vnode(r), r;
  }
  function je(t) {
    return t.children;
  }
  function Pe(t, e) {
    this.props = t, this.context = e;
  }
  function ue(t, e) {
    if (e == null) return t.__ ? ue(t.__, t.__i + 1) : null;
    for (var n; e < t.__k.length; e++) if ((n = t.__k[e]) != null && n.__e != null) return n.__e;
    return typeof t.type == "function" ? ue(t) : null;
  }
  function rs(t) {
    var e, n;
    if ((t = t.__) != null && t.__c != null) {
      for (t.__e = t.__c.base = null, e = 0; e < t.__k.length; e++) if ((n = t.__k[e]) != null && n.__e != null) {
        t.__e = t.__c.base = n.__e;
        break;
      }
      return rs(t);
    }
  }
  function Nt(t) {
    (!t.__d && (t.__d = true) && re.push(t) && !Re.__r++ || Rt !== L.debounceRendering) && ((Rt = L.debounceRendering) || ts)(Re);
  }
  function Re() {
    for (var t, e, n, s, i, r, o, a = 1; re.length; ) re.length > a && re.sort(ns), t = re.shift(), a = re.length, t.__d && (n = void 0, i = (s = (e = t).__v).__e, r = [], o = [], e.__P && ((n = X({}, s)).__v = s.__v + 1, L.vnode && L.vnode(n), gt(e.__P, n, s, e.__n, e.__P.namespaceURI, 32 & s.__u ? [
      i
    ] : null, r, i ?? ue(s), !!(32 & s.__u), o), n.__v = s.__v, n.__.__k[n.__i] = n, cs(r, n, o), n.__e != i && rs(n)));
    Re.__r = 0;
  }
  function os(t, e, n, s, i, r, o, a, c, d, h) {
    var l, p, f, m, C, g, b = s && s.__k || is, w = e.length;
    for (c = Wi(n, e, b, c, w), l = 0; l < w; l++) (f = n.__k[l]) != null && (p = f.__i === -1 ? ve : b[f.__i] || ve, f.__i = l, g = gt(t, f, p, i, r, o, a, c, d, h), m = f.__e, f.ref && p.ref != f.ref && (p.ref && _t(p.ref, null, f), h.push(f.ref, f.__c || m, f)), C == null && m != null && (C = m), 4 & f.__u || p.__k === f.__k ? c = as(f, c, t) : typeof f.type == "function" && g !== void 0 ? c = g : m && (c = m.nextSibling), f.__u &= -7);
    return n.__e = C, c;
  }
  function Wi(t, e, n, s, i) {
    var r, o, a, c, d, h = n.length, l = h, p = 0;
    for (t.__k = new Array(i), r = 0; r < i; r++) (o = e[r]) != null && typeof o != "boolean" && typeof o != "function" ? (c = r + p, (o = t.__k[r] = typeof o == "string" || typeof o == "number" || typeof o == "bigint" || o.constructor == String ? Me(null, o, null, null, null) : ft(o) ? Me(je, {
      children: o
    }, null, null, null) : o.constructor === void 0 && o.__b > 0 ? Me(o.type, o.props, o.key, o.ref ? o.ref : null, o.__v) : o).__ = t, o.__b = t.__b + 1, a = null, (d = o.__i = qi(o, n, c, l)) !== -1 && (l--, (a = n[d]) && (a.__u |= 2)), a == null || a.__v === null ? (d == -1 && p--, typeof o.type != "function" && (o.__u |= 4)) : d != c && (d == c - 1 ? p-- : d == c + 1 ? p++ : (d > c ? p-- : p++, o.__u |= 4))) : t.__k[r] = null;
    if (l) for (r = 0; r < h; r++) (a = n[r]) != null && !(2 & a.__u) && (a.__e == s && (s = ue(a)), ls(a, a));
    return s;
  }
  function as(t, e, n) {
    var s, i;
    if (typeof t.type == "function") {
      for (s = t.__k, i = 0; s && i < s.length; i++) s[i] && (s[i].__ = t, e = as(s[i], e, n));
      return e;
    }
    t.__e != e && (e && t.type && !n.contains(e) && (e = ue(t)), n.insertBefore(t.__e, e || null), e = t.__e);
    do
      e = e && e.nextSibling;
    while (e != null && e.nodeType == 8);
    return e;
  }
  function qi(t, e, n, s) {
    var i, r, o = t.key, a = t.type, c = e[n];
    if (c === null || c && o == c.key && a === c.type && !(2 & c.__u)) return n;
    if (s > (c != null && !(2 & c.__u) ? 1 : 0)) for (i = n - 1, r = n + 1; i >= 0 || r < e.length; ) {
      if (i >= 0) {
        if ((c = e[i]) && !(2 & c.__u) && o == c.key && a === c.type) return i;
        i--;
      }
      if (r < e.length) {
        if ((c = e[r]) && !(2 & c.__u) && o == c.key && a === c.type) return r;
        r++;
      }
    }
    return -1;
  }
  function Ot(t, e, n) {
    e[0] == "-" ? t.setProperty(e, n ?? "") : t[e] = n == null ? "" : typeof n != "number" || Bi.test(e) ? n : n + "px";
  }
  function Le(t, e, n, s, i) {
    var r;
    e: if (e == "style") if (typeof n == "string") t.style.cssText = n;
    else {
      if (typeof s == "string" && (t.style.cssText = s = ""), s) for (e in s) n && e in n || Ot(t.style, e, "");
      if (n) for (e in n) s && n[e] === s[e] || Ot(t.style, e, n[e]);
    }
    else if (e[0] == "o" && e[1] == "n") r = e != (e = e.replace(ss, "$1")), e = e.toLowerCase() in t || e == "onFocusOut" || e == "onFocusIn" ? e.toLowerCase().slice(2) : e.slice(2), t.l || (t.l = {}), t.l[e + r] = n, n ? s ? n.u = s.u : (n.u = ut, t.addEventListener(e, r ? et : Xe, r)) : t.removeEventListener(e, r ? et : Xe, r);
    else {
      if (i == "http://www.w3.org/2000/svg") e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (e != "width" && e != "height" && e != "href" && e != "list" && e != "form" && e != "tabIndex" && e != "download" && e != "rowSpan" && e != "colSpan" && e != "role" && e != "popover" && e in t) try {
        t[e] = n ?? "";
        break e;
      } catch {
      }
      typeof n == "function" || (n == null || n === false && e[4] != "-" ? t.removeAttribute(e) : t.setAttribute(e, e == "popover" && n == 1 ? "" : n));
    }
  }
  function Dt(t) {
    return function(e) {
      if (this.l) {
        var n = this.l[e.type + t];
        if (e.t == null) e.t = ut++;
        else if (e.t < n.u) return;
        return n(L.event ? L.event(e) : e);
      }
    };
  }
  function gt(t, e, n, s, i, r, o, a, c, d) {
    var h, l, p, f, m, C, g, b, w, k, U, H, ne, Ce, oe, xe, ae, u, _ = e.type;
    if (e.constructor !== void 0) return null;
    128 & n.__u && (c = !!(32 & n.__u), r = [
      a = e.__e = n.__e
    ]), (h = L.__b) && h(e);
    e: if (typeof _ == "function") try {
      if (b = e.props, w = "prototype" in _ && _.prototype.render, k = (h = _.contextType) && s[h.__c], U = h ? k ? k.props.value : h.__ : s, n.__c ? g = (l = e.__c = n.__c).__ = l.__E : (w ? e.__c = l = new _(b, U) : (e.__c = l = new Pe(b, U), l.constructor = _, l.render = Ki), k && k.sub(l), l.props = b, l.state || (l.state = {}), l.context = U, l.__n = s, p = l.__d = true, l.__h = [], l._sb = []), w && l.__s == null && (l.__s = l.state), w && _.getDerivedStateFromProps != null && (l.__s == l.state && (l.__s = X({}, l.__s)), X(l.__s, _.getDerivedStateFromProps(b, l.__s))), f = l.props, m = l.state, l.__v = e, p) w && _.getDerivedStateFromProps == null && l.componentWillMount != null && l.componentWillMount(), w && l.componentDidMount != null && l.__h.push(l.componentDidMount);
      else {
        if (w && _.getDerivedStateFromProps == null && b !== f && l.componentWillReceiveProps != null && l.componentWillReceiveProps(b, U), !l.__e && (l.shouldComponentUpdate != null && l.shouldComponentUpdate(b, l.__s, U) === false || e.__v == n.__v)) {
          for (e.__v != n.__v && (l.props = b, l.state = l.__s, l.__d = false), e.__e = n.__e, e.__k = n.__k, e.__k.some(function(x) {
            x && (x.__ = e);
          }), H = 0; H < l._sb.length; H++) l.__h.push(l._sb[H]);
          l._sb = [], l.__h.length && o.push(l);
          break e;
        }
        l.componentWillUpdate != null && l.componentWillUpdate(b, l.__s, U), w && l.componentDidUpdate != null && l.__h.push(function() {
          l.componentDidUpdate(f, m, C);
        });
      }
      if (l.context = U, l.props = b, l.__P = t, l.__e = false, ne = L.__r, Ce = 0, w) {
        for (l.state = l.__s, l.__d = false, ne && ne(e), h = l.render(l.props, l.state, l.context), oe = 0; oe < l._sb.length; oe++) l.__h.push(l._sb[oe]);
        l._sb = [];
      } else do
        l.__d = false, ne && ne(e), h = l.render(l.props, l.state, l.context), l.state = l.__s;
      while (l.__d && ++Ce < 25);
      l.state = l.__s, l.getChildContext != null && (s = X(X({}, s), l.getChildContext())), w && !p && l.getSnapshotBeforeUpdate != null && (C = l.getSnapshotBeforeUpdate(f, m)), ae = (xe = h != null && h.type === je && h.key == null) ? h.props.children : h, xe && (h.props.children = null), a = os(t, ft(ae) ? ae : [
        ae
      ], e, n, s, i, r, o, a, c, d), l.base = e.__e, e.__u &= -161, l.__h.length && o.push(l), g && (l.__E = l.__ = null);
    } catch (x) {
      if (e.__v = null, c || r != null) if (x.then) {
        for (e.__u |= c ? 160 : 128; a && a.nodeType == 8 && a.nextSibling; ) a = a.nextSibling;
        r[r.indexOf(a)] = null, e.__e = a;
      } else for (u = r.length; u--; ) pt(r[u]);
      else e.__e = n.__e, e.__k = n.__k;
      L.__e(x, e, n);
    }
    else r == null && e.__v == n.__v ? (e.__k = n.__k, e.__e = n.__e) : a = e.__e = Vi(n.__e, e, n, s, i, r, o, c, d);
    return (h = L.diffed) && h(e), 128 & e.__u ? void 0 : a;
  }
  function cs(t, e, n) {
    for (var s = 0; s < n.length; s++) _t(n[s], n[++s], n[++s]);
    L.__c && L.__c(e, t), t.some(function(i) {
      try {
        t = i.__h, i.__h = [], t.some(function(r) {
          r.call(i);
        });
      } catch (r) {
        L.__e(r, i.__v);
      }
    });
  }
  function Vi(t, e, n, s, i, r, o, a, c) {
    var d, h, l, p, f, m, C, g = n.props, b = e.props, w = e.type;
    if (w == "svg" ? i = "http://www.w3.org/2000/svg" : w == "math" ? i = "http://www.w3.org/1998/Math/MathML" : i || (i = "http://www.w3.org/1999/xhtml"), r != null) {
      for (d = 0; d < r.length; d++) if ((f = r[d]) && "setAttribute" in f == !!w && (w ? f.localName == w : f.nodeType == 3)) {
        t = f, r[d] = null;
        break;
      }
    }
    if (t == null) {
      if (w == null) return document.createTextNode(b);
      t = document.createElementNS(i, w, b.is && b), a && (L.__m && L.__m(e, r), a = false), r = null;
    }
    if (w === null) g === b || a && t.data === b || (t.data = b);
    else {
      if (r = r && He.call(t.childNodes), g = n.props || ve, !a && r != null) for (g = {}, d = 0; d < t.attributes.length; d++) g[(f = t.attributes[d]).name] = f.value;
      for (d in g) if (f = g[d], d != "children") {
        if (d == "dangerouslySetInnerHTML") l = f;
        else if (!(d in b)) {
          if (d == "value" && "defaultValue" in b || d == "checked" && "defaultChecked" in b) continue;
          Le(t, d, null, f, i);
        }
      }
      for (d in b) f = b[d], d == "children" ? p = f : d == "dangerouslySetInnerHTML" ? h = f : d == "value" ? m = f : d == "checked" ? C = f : a && typeof f != "function" || g[d] === f || Le(t, d, f, g[d], i);
      if (h) a || l && (h.__html === l.__html || h.__html === t.innerHTML) || (t.innerHTML = h.__html), e.__k = [];
      else if (l && (t.innerHTML = ""), os(e.type === "template" ? t.content : t, ft(p) ? p : [
        p
      ], e, n, s, w == "foreignObject" ? "http://www.w3.org/1999/xhtml" : i, r, o, r ? r[0] : n.__k && ue(n, 0), a, c), r != null) for (d = r.length; d--; ) pt(r[d]);
      a || (d = "value", w == "progress" && m == null ? t.removeAttribute("value") : m !== void 0 && (m !== t[d] || w == "progress" && !m || w == "option" && m !== g[d]) && Le(t, d, m, g[d], i), d = "checked", C !== void 0 && C !== t[d] && Le(t, d, C, g[d], i));
    }
    return t;
  }
  function _t(t, e, n) {
    try {
      if (typeof t == "function") {
        var s = typeof t.__u == "function";
        s && t.__u(), s && e == null || (t.__u = t(e));
      } else t.current = e;
    } catch (i) {
      L.__e(i, n);
    }
  }
  function ls(t, e, n) {
    var s, i;
    if (L.unmount && L.unmount(t), (s = t.ref) && (s.current && s.current !== t.__e || _t(s, null, e)), (s = t.__c) != null) {
      if (s.componentWillUnmount) try {
        s.componentWillUnmount();
      } catch (r) {
        L.__e(r, e);
      }
      s.base = s.__P = null;
    }
    if (s = t.__k) for (i = 0; i < s.length; i++) s[i] && ls(s[i], e, n || typeof t.type != "function");
    n || pt(t.__e), t.__c = t.__ = t.__e = void 0;
  }
  function Ki(t, e, n) {
    return this.constructor(t, n);
  }
  function tt(t, e, n) {
    var s, i, r, o;
    e == document && (e = document.documentElement), L.__ && L.__(t, e), i = (s = false) ? null : e.__k, r = [], o = [], gt(e, t = e.__k = E(je, null, [
      t
    ]), i || ve, ve, e.namespaceURI, i ? null : e.firstChild ? He.call(e.childNodes) : null, r, i ? i.__e : e.firstChild, s, o), cs(r, t, o);
  }
  He = is.slice, L = {
    __e: function(t, e, n, s) {
      for (var i, r, o; e = e.__; ) if ((i = e.__c) && !i.__) try {
        if ((r = i.constructor) && r.getDerivedStateFromError != null && (i.setState(r.getDerivedStateFromError(t)), o = i.__d), i.componentDidCatch != null && (i.componentDidCatch(t, s || {}), o = i.__d), o) return i.__E = i;
      } catch (a) {
        t = a;
      }
      throw t;
    }
  }, es = 0, Pe.prototype.setState = function(t, e) {
    var n;
    n = this.__s != null && this.__s !== this.state ? this.__s : this.__s = X({}, this.state), typeof t == "function" && (t = t(X({}, n), this.props)), t && X(n, t), t != null && this.__v && (e && this._sb.push(e), Nt(this));
  }, Pe.prototype.forceUpdate = function(t) {
    this.__v && (this.__e = true, t && this.__h.push(t), Nt(this));
  }, Pe.prototype.render = je, re = [], ts = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, ns = function(t, e) {
    return t.__v.__b - e.__v.__b;
  }, Re.__r = 0, ss = /(PointerCapture)$|Capture$/i, ut = 0, Xe = Dt(false), et = Dt(true);
  var Ne, P, $e, Ut, nt = 0, ds = [], T = L, Ht = T.__b, jt = T.__r, Bt = T.diffed, Wt = T.__c, qt = T.unmount, Vt = T.__;
  function hs(t, e) {
    T.__h && T.__h(P, t, nt || e), nt = 0;
    var n = P.__H || (P.__H = {
      __: [],
      __h: []
    });
    return t >= n.__.length && n.__.push({}), n.__[t];
  }
  function Kt(t) {
    return nt = 1, Fi(us, t);
  }
  function Fi(t, e, n) {
    var s = hs(Ne++, 2);
    if (s.t = t, !s.__c && (s.__ = [
      us(void 0, e),
      function(a) {
        var c = s.__N ? s.__N[0] : s.__[0], d = s.t(c, a);
        c !== d && (s.__N = [
          d,
          s.__[1]
        ], s.__c.setState({}));
      }
    ], s.__c = P, !P.__f)) {
      var i = function(a, c, d) {
        if (!s.__c.__H) return true;
        var h = s.__c.__H.__.filter(function(p) {
          return !!p.__c;
        });
        if (h.every(function(p) {
          return !p.__N;
        })) return !r || r.call(this, a, c, d);
        var l = s.__c.props !== a;
        return h.forEach(function(p) {
          if (p.__N) {
            var f = p.__[0];
            p.__ = p.__N, p.__N = void 0, f !== p.__[0] && (l = true);
          }
        }), r && r.call(this, a, c, d) || l;
      };
      P.__f = true;
      var r = P.shouldComponentUpdate, o = P.componentWillUpdate;
      P.componentWillUpdate = function(a, c, d) {
        if (this.__e) {
          var h = r;
          r = void 0, i(a, c, d), r = h;
        }
        o && o.call(this, a, c, d);
      }, P.shouldComponentUpdate = i;
    }
    return s.__N || s.__;
  }
  function $i(t, e) {
    var n = hs(Ne++, 3);
    !T.__s && Gi(n.__H, e) && (n.__ = t, n.u = e, P.__H.__h.push(n));
  }
  function zi() {
    for (var t; t = ds.shift(); ) if (t.__P && t.__H) try {
      t.__H.__h.forEach(Te), t.__H.__h.forEach(st), t.__H.__h = [];
    } catch (e) {
      t.__H.__h = [], T.__e(e, t.__v);
    }
  }
  T.__b = function(t) {
    P = null, Ht && Ht(t);
  }, T.__ = function(t, e) {
    t && e.__k && e.__k.__m && (t.__m = e.__k.__m), Vt && Vt(t, e);
  }, T.__r = function(t) {
    jt && jt(t), Ne = 0;
    var e = (P = t.__c).__H;
    e && ($e === P ? (e.__h = [], P.__h = [], e.__.forEach(function(n) {
      n.__N && (n.__ = n.__N), n.u = n.__N = void 0;
    })) : (e.__h.forEach(Te), e.__h.forEach(st), e.__h = [], Ne = 0)), $e = P;
  }, T.diffed = function(t) {
    Bt && Bt(t);
    var e = t.__c;
    e && e.__H && (e.__H.__h.length && (ds.push(e) !== 1 && Ut === T.requestAnimationFrame || ((Ut = T.requestAnimationFrame) || Zi)(zi)), e.__H.__.forEach(function(n) {
      n.u && (n.__H = n.u), n.u = void 0;
    })), $e = P = null;
  }, T.__c = function(t, e) {
    e.some(function(n) {
      try {
        n.__h.forEach(Te), n.__h = n.__h.filter(function(s) {
          return !s.__ || st(s);
        });
      } catch (s) {
        e.some(function(i) {
          i.__h && (i.__h = []);
        }), e = [], T.__e(s, n.__v);
      }
    }), Wt && Wt(t, e);
  }, T.unmount = function(t) {
    qt && qt(t);
    var e, n = t.__c;
    n && n.__H && (n.__H.__.forEach(function(s) {
      try {
        Te(s);
      } catch (i) {
        e = i;
      }
    }), n.__H = void 0, e && T.__e(e, n.__v));
  };
  var Ft = typeof requestAnimationFrame == "function";
  function Zi(t) {
    var e, n = function() {
      clearTimeout(s), Ft && cancelAnimationFrame(e), setTimeout(t);
    }, s = setTimeout(n, 100);
    Ft && (e = requestAnimationFrame(n));
  }
  function Te(t) {
    var e = P, n = t.__c;
    typeof n == "function" && (t.__c = void 0, n()), P = e;
  }
  function st(t) {
    var e = P;
    t.__c = t.__(), P = e;
  }
  function Gi(t, e) {
    return !t || t.length !== e.length || e.some(function(n, s) {
      return n !== t[s];
    });
  }
  function us(t, e) {
    return typeof e == "function" ? e(t) : e;
  }
  const Yi = ".-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}", Ji = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+", Qi = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=";
  class Xi {
    constructor() {
      this.items = /* @__PURE__ */ new Map(), this.nextItemKey = 0, this.root = null, this.darkMode = Qn();
    }
    attach(e) {
      this.root = document.createElement("div"), this.root.className = "-cbwsdk-snackbar-root", e.appendChild(this.root), this.render();
    }
    presentItem(e) {
      const n = this.nextItemKey++;
      return this.items.set(n, e), this.render(), () => {
        this.items.delete(n), this.render();
      };
    }
    clear() {
      this.items.clear(), this.render();
    }
    render() {
      this.root && tt(E("div", null, E(fs, {
        darkMode: this.darkMode
      }, Array.from(this.items.entries()).map(([e, n]) => E(er, Object.assign({}, n, {
        key: e
      }))))), this.root);
    }
  }
  const fs = (t) => E("div", {
    class: ge("-cbwsdk-snackbar-container")
  }, E("style", null, Yi), E("div", {
    class: "-cbwsdk-snackbar"
  }, t.children)), er = ({ autoExpand: t, message: e, menuItems: n }) => {
    const [s, i] = Kt(true), [r, o] = Kt(t ?? false);
    $i(() => {
      const c = [
        window.setTimeout(() => {
          i(false);
        }, 1),
        window.setTimeout(() => {
          o(true);
        }, 1e4)
      ];
      return () => {
        c.forEach(window.clearTimeout);
      };
    });
    const a = () => {
      o(!r);
    };
    return E("div", {
      class: ge("-cbwsdk-snackbar-instance", s && "-cbwsdk-snackbar-instance-hidden", r && "-cbwsdk-snackbar-instance-expanded")
    }, E("div", {
      class: "-cbwsdk-snackbar-instance-header",
      onClick: a
    }, E("img", {
      src: Ji,
      class: "-cbwsdk-snackbar-instance-header-cblogo"
    }), " ", E("div", {
      class: "-cbwsdk-snackbar-instance-header-message"
    }, e), E("div", {
      class: "-gear-container"
    }, !r && E("svg", {
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, E("circle", {
      cx: "12",
      cy: "12",
      r: "12",
      fill: "#F5F7F8"
    })), E("img", {
      src: Qi,
      class: "-gear-icon",
      title: "Expand"
    }))), n && n.length > 0 && E("div", {
      class: "-cbwsdk-snackbar-instance-menu"
    }, n.map((c, d) => E("div", {
      class: ge("-cbwsdk-snackbar-instance-menu-item", c.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"),
      onClick: c.onClick,
      key: d
    }, E("svg", {
      width: c.svgWidth,
      height: c.svgHeight,
      viewBox: "0 0 10 11",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, E("path", {
      "fill-rule": c.defaultFillRule,
      "clip-rule": c.defaultClipRule,
      d: c.path,
      fill: "#AAAAAA"
    })), E("span", {
      class: ge("-cbwsdk-snackbar-instance-menu-item-info", c.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red")
    }, c.info)))));
  };
  class tr {
    constructor() {
      this.attached = false, this.snackbar = new Xi();
    }
    attach() {
      if (this.attached) throw new Error("Coinbase Wallet SDK UI is already attached");
      const e = document.documentElement, n = document.createElement("div");
      n.className = "-cbwsdk-css-reset", e.appendChild(n), this.snackbar.attach(n), this.attached = true, Xn();
    }
    showConnecting(e) {
      let n;
      return e.isUnlinkedErrorState ? n = {
        autoExpand: true,
        message: "Connection lost",
        menuItems: [
          {
            isRed: false,
            info: "Reset connection",
            svgWidth: "10",
            svgHeight: "11",
            path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
            defaultFillRule: "evenodd",
            defaultClipRule: "evenodd",
            onClick: e.onResetConnection
          }
        ]
      } : n = {
        message: "Confirm on phone",
        menuItems: [
          {
            isRed: true,
            info: "Cancel transaction",
            svgWidth: "11",
            svgHeight: "11",
            path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
            defaultFillRule: "inherit",
            defaultClipRule: "inherit",
            onClick: e.onCancel
          },
          {
            isRed: false,
            info: "Reset connection",
            svgWidth: "10",
            svgHeight: "11",
            path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
            defaultFillRule: "evenodd",
            defaultClipRule: "evenodd",
            onClick: e.onResetConnection
          }
        ]
      }, this.snackbar.presentItem(n);
    }
  }
  const nr = ".-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s;background-color:rgba(10,11,13,.5)}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box{display:block;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);padding:20px;border-radius:8px;background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box p{display:block;font-weight:400;font-size:14px;line-height:20px;padding-bottom:12px;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box button{appearance:none;border:none;background:none;color:#0052ff;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark{background-color:#0a0b0d;color:#fff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark button{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light{background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light button{color:#0052ff}";
  class sr {
    constructor() {
      this.root = null, this.darkMode = Qn();
    }
    attach() {
      const e = document.documentElement;
      this.root = document.createElement("div"), this.root.className = "-cbwsdk-css-reset", e.appendChild(this.root), Xn();
    }
    present(e) {
      this.render(e);
    }
    clear() {
      this.render(null);
    }
    render(e) {
      this.root && (tt(null, this.root), e && tt(E(ir, Object.assign({}, e, {
        onDismiss: () => {
          this.clear();
        },
        darkMode: this.darkMode
      })), this.root));
    }
  }
  const ir = ({ title: t, buttonText: e, darkMode: n, onButtonClick: s, onDismiss: i }) => {
    const r = n ? "dark" : "light";
    return E(fs, {
      darkMode: n
    }, E("div", {
      class: "-cbwsdk-redirect-dialog"
    }, E("style", null, nr), E("div", {
      class: "-cbwsdk-redirect-dialog-backdrop",
      onClick: i
    }), E("div", {
      class: ge("-cbwsdk-redirect-dialog-box", r)
    }, E("p", null, t), E("button", {
      onClick: s
    }, e))));
  }, rr = "https://keys.coinbase.com/connect", or = "http://rpc.wallet.coinbase.com", $t = "https://www.walletlink.org", ar = "https://go.cb-w.com/walletlink";
  class zt {
    constructor() {
      this.attached = false, this.redirectDialog = new sr();
    }
    attach() {
      if (this.attached) throw new Error("Coinbase Wallet SDK UI is already attached");
      this.redirectDialog.attach(), this.attached = true;
    }
    redirectToCoinbaseWallet(e) {
      const n = new URL(ar);
      n.searchParams.append("redirect_url", Ui().href), e && n.searchParams.append("wl_url", e);
      const s = document.createElement("a");
      s.target = "cbw-opener", s.href = n.href, s.rel = "noreferrer noopener", s.click();
    }
    openCoinbaseWalletDeeplink(e) {
      this.redirectDialog.present({
        title: "Redirecting to Coinbase Wallet...",
        buttonText: "Open",
        onButtonClick: () => {
          this.redirectToCoinbaseWallet(e);
        }
      }), setTimeout(() => {
        this.redirectToCoinbaseWallet(e);
      }, 99);
    }
    showConnecting(e) {
      return () => {
        this.redirectDialog.clear();
      };
    }
  }
  class z {
    constructor(e) {
      this.chainCallbackParams = {
        chainId: "",
        jsonRpcUrl: ""
      }, this.isMobileWeb = Hi(), this.linkedUpdated = (r) => {
        this.isLinked = r;
        const o = this.storage.getItem(Qe);
        if (r && (this._session.linked = r), this.isUnlinkedErrorState = false, o) {
          const a = o.split(" "), c = this.storage.getItem("IsStandaloneSigning") === "true";
          a[0] !== "" && !r && this._session.linked && !c && (this.isUnlinkedErrorState = true);
        }
      }, this.metadataUpdated = (r, o) => {
        this.storage.setItem(r, o);
      }, this.chainUpdated = (r, o) => {
        this.chainCallbackParams.chainId === r && this.chainCallbackParams.jsonRpcUrl === o || (this.chainCallbackParams = {
          chainId: r,
          jsonRpcUrl: o
        }, this.chainCallback && this.chainCallback(o, Number.parseInt(r, 10)));
      }, this.accountUpdated = (r) => {
        this.accountsCallback && this.accountsCallback([
          r
        ]), z.accountRequestCallbackIds.size > 0 && (Array.from(z.accountRequestCallbackIds.values()).forEach((o) => {
          this.invokeCallback(o, {
            method: "requestEthereumAccounts",
            result: [
              r
            ]
          });
        }), z.accountRequestCallbackIds.clear());
      }, this.resetAndReload = this.resetAndReload.bind(this), this.linkAPIUrl = e.linkAPIUrl, this.storage = e.storage, this.metadata = e.metadata, this.accountsCallback = e.accountsCallback, this.chainCallback = e.chainCallback;
      const { session: n, ui: s, connection: i } = this.subscribe();
      this._session = n, this.connection = i, this.relayEventManager = new vi(), this.ui = s, this.ui.attach();
    }
    subscribe() {
      const e = he.load(this.storage) || he.create(this.storage), { linkAPIUrl: n } = this, s = new wi({
        session: e,
        linkAPIUrl: n,
        listener: this
      }), i = this.isMobileWeb ? new zt() : new tr();
      return s.connect(), {
        session: e,
        ui: i,
        connection: s
      };
    }
    resetAndReload() {
      this.connection.destroy().then(() => {
        const e = he.load(this.storage);
        (e == null ? void 0 : e.id) === this._session.id && K.clearAll(), document.location.reload();
      }).catch((e) => {
      });
    }
    signEthereumTransaction(e) {
      return this.sendRequest({
        method: "signEthereumTransaction",
        params: {
          fromAddress: e.fromAddress,
          toAddress: e.toAddress,
          weiValue: W(e.weiValue),
          data: _e(e.data, true),
          nonce: e.nonce,
          gasPriceInWei: e.gasPriceInWei ? W(e.gasPriceInWei) : null,
          maxFeePerGas: e.gasPriceInWei ? W(e.gasPriceInWei) : null,
          maxPriorityFeePerGas: e.gasPriceInWei ? W(e.gasPriceInWei) : null,
          gasLimit: e.gasLimit ? W(e.gasLimit) : null,
          chainId: e.chainId,
          shouldSubmit: false
        }
      });
    }
    signAndSubmitEthereumTransaction(e) {
      return this.sendRequest({
        method: "signEthereumTransaction",
        params: {
          fromAddress: e.fromAddress,
          toAddress: e.toAddress,
          weiValue: W(e.weiValue),
          data: _e(e.data, true),
          nonce: e.nonce,
          gasPriceInWei: e.gasPriceInWei ? W(e.gasPriceInWei) : null,
          maxFeePerGas: e.maxFeePerGas ? W(e.maxFeePerGas) : null,
          maxPriorityFeePerGas: e.maxPriorityFeePerGas ? W(e.maxPriorityFeePerGas) : null,
          gasLimit: e.gasLimit ? W(e.gasLimit) : null,
          chainId: e.chainId,
          shouldSubmit: true
        }
      });
    }
    submitEthereumTransaction(e, n) {
      return this.sendRequest({
        method: "submitEthereumTransaction",
        params: {
          signedTransaction: _e(e, true),
          chainId: n
        }
      });
    }
    getWalletLinkSession() {
      return this._session;
    }
    sendRequest(e) {
      let n = null;
      const s = se(8), i = (r) => {
        this.publishWeb3RequestCanceledEvent(s), this.handleErrorResponse(s, e.method, r), n == null ? void 0 : n();
      };
      return new Promise((r, o) => {
        n = this.ui.showConnecting({
          isUnlinkedErrorState: this.isUnlinkedErrorState,
          onCancel: i,
          onResetConnection: this.resetAndReload
        }), this.relayEventManager.callbacks.set(s, (a) => {
          if (n == null ? void 0 : n(), N(a)) return o(new Error(a.errorMessage));
          r(a);
        }), this.publishWeb3RequestEvent(s, e);
      });
    }
    publishWeb3RequestEvent(e, n) {
      const s = {
        type: "WEB3_REQUEST",
        id: e,
        request: n
      };
      this.publishEvent("Web3Request", s, true).then((i) => {
      }).catch((i) => {
        this.handleWeb3ResponseMessage(s.id, {
          method: n.method,
          errorMessage: i.message
        });
      }), this.isMobileWeb && this.openCoinbaseWalletDeeplink(n.method);
    }
    openCoinbaseWalletDeeplink(e) {
      if (this.ui instanceof zt) switch (e) {
        case "requestEthereumAccounts":
        case "switchEthereumChain":
          return;
        default:
          window.addEventListener("blur", () => {
            window.addEventListener("focus", () => {
              this.connection.checkUnseenEvents();
            }, {
              once: true
            });
          }, {
            once: true
          }), this.ui.openCoinbaseWalletDeeplink();
          break;
      }
    }
    publishWeb3RequestCanceledEvent(e) {
      const n = {
        type: "WEB3_REQUEST_CANCELED",
        id: e
      };
      this.publishEvent("Web3RequestCanceled", n, false).then();
    }
    publishEvent(e, n, s) {
      return this.connection.publishEvent(e, n, s);
    }
    handleWeb3ResponseMessage(e, n) {
      if (n.method === "requestEthereumAccounts") {
        z.accountRequestCallbackIds.forEach((s) => this.invokeCallback(s, n)), z.accountRequestCallbackIds.clear();
        return;
      }
      this.invokeCallback(e, n);
    }
    handleErrorResponse(e, n, s) {
      var i;
      const r = (i = s == null ? void 0 : s.message) !== null && i !== void 0 ? i : "Unspecified error message.";
      this.handleWeb3ResponseMessage(e, {
        method: n,
        errorMessage: r
      });
    }
    invokeCallback(e, n) {
      const s = this.relayEventManager.callbacks.get(e);
      s && (s(n), this.relayEventManager.callbacks.delete(e));
    }
    requestEthereumAccounts() {
      const { appName: e, appLogoUrl: n } = this.metadata, s = {
        method: "requestEthereumAccounts",
        params: {
          appName: e,
          appLogoUrl: n
        }
      }, i = se(8);
      return new Promise((r, o) => {
        this.relayEventManager.callbacks.set(i, (a) => {
          if (N(a)) return o(new Error(a.errorMessage));
          r(a);
        }), z.accountRequestCallbackIds.add(i), this.publishWeb3RequestEvent(i, s);
      });
    }
    watchAsset(e, n, s, i, r, o) {
      const a = {
        method: "watchAsset",
        params: {
          type: e,
          options: {
            address: n,
            symbol: s,
            decimals: i,
            image: r
          },
          chainId: o
        }
      };
      let c = null;
      const d = se(8), h = (l) => {
        this.publishWeb3RequestCanceledEvent(d), this.handleErrorResponse(d, a.method, l), c == null ? void 0 : c();
      };
      return c = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: h,
        onResetConnection: this.resetAndReload
      }), new Promise((l, p) => {
        this.relayEventManager.callbacks.set(d, (f) => {
          if (c == null ? void 0 : c(), N(f)) return p(new Error(f.errorMessage));
          l(f);
        }), this.publishWeb3RequestEvent(d, a);
      });
    }
    addEthereumChain(e, n, s, i, r, o) {
      const a = {
        method: "addEthereumChain",
        params: {
          chainId: e,
          rpcUrls: n,
          blockExplorerUrls: i,
          chainName: r,
          iconUrls: s,
          nativeCurrency: o
        }
      };
      let c = null;
      const d = se(8), h = (l) => {
        this.publishWeb3RequestCanceledEvent(d), this.handleErrorResponse(d, a.method, l), c == null ? void 0 : c();
      };
      return c = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: h,
        onResetConnection: this.resetAndReload
      }), new Promise((l, p) => {
        this.relayEventManager.callbacks.set(d, (f) => {
          if (c == null ? void 0 : c(), N(f)) return p(new Error(f.errorMessage));
          l(f);
        }), this.publishWeb3RequestEvent(d, a);
      });
    }
    switchEthereumChain(e, n) {
      const s = {
        method: "switchEthereumChain",
        params: Object.assign({
          chainId: e
        }, {
          address: n
        })
      };
      let i = null;
      const r = se(8), o = (a) => {
        this.publishWeb3RequestCanceledEvent(r), this.handleErrorResponse(r, s.method, a), i == null ? void 0 : i();
      };
      return i = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: o,
        onResetConnection: this.resetAndReload
      }), new Promise((a, c) => {
        this.relayEventManager.callbacks.set(r, (d) => {
          if (i == null ? void 0 : i(), N(d) && d.errorCode) return c(v.provider.custom({
            code: d.errorCode,
            message: "Unrecognized chain ID. Try adding the chain using addEthereumChain first."
          }));
          if (N(d)) return c(new Error(d.errorMessage));
          a(d);
        }), this.publishWeb3RequestEvent(r, s);
      });
    }
  }
  z.accountRequestCallbackIds = /* @__PURE__ */ new Set();
  const Zt = "DefaultChainId", Gt = "DefaultJsonRpcUrl";
  class ps {
    constructor(e) {
      this._relay = null, this._addresses = [], this.metadata = e.metadata, this._storage = new K("walletlink", $t), this.callback = e.callback || null;
      const n = this._storage.getItem(Qe);
      if (n) {
        const s = n.split(" ");
        s[0] !== "" && (this._addresses = s.map((i) => G(i)));
      }
      this.initializeRelay();
    }
    getSession() {
      const e = this.initializeRelay(), { id: n, secret: s } = e.getWalletLinkSession();
      return {
        id: n,
        secret: s
      };
    }
    async handshake() {
      await this._eth_requestAccounts();
    }
    get selectedAddress() {
      return this._addresses[0] || void 0;
    }
    get jsonRpcUrl() {
      var e;
      return (e = this._storage.getItem(Gt)) !== null && e !== void 0 ? e : void 0;
    }
    set jsonRpcUrl(e) {
      this._storage.setItem(Gt, e);
    }
    updateProviderInfo(e, n) {
      var s;
      this.jsonRpcUrl = e;
      const i = this.getChainId();
      this._storage.setItem(Zt, n.toString(10)), me(n) !== i && ((s = this.callback) === null || s === void 0 || s.call(this, "chainChanged", Q(n)));
    }
    async watchAsset(e) {
      const n = Array.isArray(e) ? e[0] : e;
      if (!n.type) throw v.rpc.invalidParams("Type is required");
      if ((n == null ? void 0 : n.type) !== "ERC20") throw v.rpc.invalidParams(`Asset of type '${n.type}' is not supported`);
      if (!(n == null ? void 0 : n.options)) throw v.rpc.invalidParams("Options are required");
      if (!(n == null ? void 0 : n.options.address)) throw v.rpc.invalidParams("Address is required");
      const s = this.getChainId(), { address: i, symbol: r, image: o, decimals: a } = n.options, d = await this.initializeRelay().watchAsset(n.type, i, r, a, o, s == null ? void 0 : s.toString());
      return N(d) ? false : !!d.result;
    }
    async addEthereumChain(e) {
      var n, s;
      const i = e[0];
      if (((n = i.rpcUrls) === null || n === void 0 ? void 0 : n.length) === 0) throw v.rpc.invalidParams("please pass in at least 1 rpcUrl");
      if (!i.chainName || i.chainName.trim() === "") throw v.rpc.invalidParams("chainName is a required field");
      if (!i.nativeCurrency) throw v.rpc.invalidParams("nativeCurrency is a required field");
      const r = Number.parseInt(i.chainId, 16);
      if (r === this.getChainId()) return false;
      const o = this.initializeRelay(), { rpcUrls: a = [], blockExplorerUrls: c = [], chainName: d, iconUrls: h = [], nativeCurrency: l } = i, p = await o.addEthereumChain(r.toString(), a, h, c, d, l);
      if (N(p)) return false;
      if (((s = p.result) === null || s === void 0 ? void 0 : s.isApproved) === true) return this.updateProviderInfo(a[0], r), null;
      throw v.rpc.internal("unable to add ethereum chain");
    }
    async switchEthereumChain(e) {
      const n = e[0], s = Number.parseInt(n.chainId, 16), r = await this.initializeRelay().switchEthereumChain(s.toString(10), this.selectedAddress || void 0);
      if (N(r)) throw r;
      const o = r.result;
      return o.isApproved && o.rpcUrl.length > 0 && this.updateProviderInfo(o.rpcUrl, s), null;
    }
    async cleanup() {
      this.callback = null, this._relay && this._relay.resetAndReload(), this._storage.clear();
    }
    _setAddresses(e, n) {
      var s;
      if (!Array.isArray(e)) throw new Error("addresses is not an array");
      const i = e.map((r) => G(r));
      JSON.stringify(i) !== JSON.stringify(this._addresses) && (this._addresses = i, (s = this.callback) === null || s === void 0 || s.call(this, "accountsChanged", i), this._storage.setItem(Qe, i.join(" ")));
    }
    async request(e) {
      const n = e.params || [];
      switch (e.method) {
        case "eth_accounts":
          return [
            ...this._addresses
          ];
        case "eth_coinbase":
          return this.selectedAddress || null;
        case "net_version":
          return this.getChainId().toString(10);
        case "eth_chainId":
          return Q(this.getChainId());
        case "eth_requestAccounts":
          return this._eth_requestAccounts();
        case "eth_ecRecover":
        case "personal_ecRecover":
          return this.ecRecover(e);
        case "personal_sign":
          return this.personalSign(e);
        case "eth_signTransaction":
          return this._eth_signTransaction(n);
        case "eth_sendRawTransaction":
          return this._eth_sendRawTransaction(n);
        case "eth_sendTransaction":
          return this._eth_sendTransaction(n);
        case "eth_signTypedData_v1":
        case "eth_signTypedData_v3":
        case "eth_signTypedData_v4":
        case "eth_signTypedData":
          return this.signTypedData(e);
        case "wallet_addEthereumChain":
          return this.addEthereumChain(n);
        case "wallet_switchEthereumChain":
          return this.switchEthereumChain(n);
        case "wallet_watchAsset":
          return this.watchAsset(n);
        default:
          if (!this.jsonRpcUrl) throw v.rpc.internal("No RPC URL set for chain");
          return lt(e, this.jsonRpcUrl);
      }
    }
    _ensureKnownAddress(e) {
      const n = G(e);
      if (!this._addresses.map((i) => G(i)).includes(n)) throw new Error("Unknown Ethereum address");
    }
    _prepareTransactionParams(e) {
      const n = e.from ? G(e.from) : this.selectedAddress;
      if (!n) throw new Error("Ethereum address is unavailable");
      this._ensureKnownAddress(n);
      const s = e.to ? G(e.to) : null, i = e.value != null ? fe(e.value) : BigInt(0), r = e.data ? Ge(e.data) : S.alloc(0), o = e.nonce != null ? me(e.nonce) : null, a = e.gasPrice != null ? fe(e.gasPrice) : null, c = e.maxFeePerGas != null ? fe(e.maxFeePerGas) : null, d = e.maxPriorityFeePerGas != null ? fe(e.maxPriorityFeePerGas) : null, h = e.gas != null ? fe(e.gas) : null, l = e.chainId ? me(e.chainId) : this.getChainId();
      return {
        fromAddress: n,
        toAddress: s,
        weiValue: i,
        data: r,
        nonce: o,
        gasPriceInWei: a,
        maxFeePerGas: c,
        maxPriorityFeePerGas: d,
        gasLimit: h,
        chainId: l
      };
    }
    async ecRecover(e) {
      const { method: n, params: s } = e;
      if (!Array.isArray(s)) throw v.rpc.invalidParams();
      const r = await this.initializeRelay().sendRequest({
        method: "ethereumAddressFromSignedMessage",
        params: {
          message: Be(s[0]),
          signature: Be(s[1]),
          addPrefix: n === "personal_ecRecover"
        }
      });
      if (N(r)) throw r;
      return r.result;
    }
    getChainId() {
      var e;
      return Number.parseInt((e = this._storage.getItem(Zt)) !== null && e !== void 0 ? e : "1", 10);
    }
    async _eth_requestAccounts() {
      var e, n;
      if (this._addresses.length > 0) return (e = this.callback) === null || e === void 0 || e.call(this, "connect", {
        chainId: Q(this.getChainId())
      }), this._addresses;
      const i = await this.initializeRelay().requestEthereumAccounts();
      if (N(i)) throw i;
      if (!i.result) throw new Error("accounts received is empty");
      return this._setAddresses(i.result), (n = this.callback) === null || n === void 0 || n.call(this, "connect", {
        chainId: Q(this.getChainId())
      }), this._addresses;
    }
    async personalSign({ params: e }) {
      if (!Array.isArray(e)) throw v.rpc.invalidParams();
      const n = e[1], s = e[0];
      this._ensureKnownAddress(n);
      const r = await this.initializeRelay().sendRequest({
        method: "signEthereumMessage",
        params: {
          address: G(n),
          message: Be(s),
          addPrefix: true,
          typedDataJson: null
        }
      });
      if (N(r)) throw r;
      return r.result;
    }
    async _eth_signTransaction(e) {
      const n = this._prepareTransactionParams(e[0] || {}), i = await this.initializeRelay().signEthereumTransaction(n);
      if (N(i)) throw i;
      return i.result;
    }
    async _eth_sendRawTransaction(e) {
      const n = Ge(e[0]), i = await this.initializeRelay().submitEthereumTransaction(n, this.getChainId());
      if (N(i)) throw i;
      return i.result;
    }
    async _eth_sendTransaction(e) {
      const n = this._prepareTransactionParams(e[0] || {}), i = await this.initializeRelay().signAndSubmitEthereumTransaction(n);
      if (N(i)) throw i;
      return i.result;
    }
    async signTypedData(e) {
      const { method: n, params: s } = e;
      if (!Array.isArray(s)) throw v.rpc.invalidParams();
      const i = (d) => {
        const h = {
          eth_signTypedData_v1: Ie.hashForSignTypedDataLegacy,
          eth_signTypedData_v3: Ie.hashForSignTypedData_v3,
          eth_signTypedData_v4: Ie.hashForSignTypedData_v4,
          eth_signTypedData: Ie.hashForSignTypedData_v4
        };
        return _e(h[n]({
          data: Is(d)
        }), true);
      }, r = s[n === "eth_signTypedData_v1" ? 1 : 0], o = s[n === "eth_signTypedData_v1" ? 0 : 1];
      this._ensureKnownAddress(r);
      const c = await this.initializeRelay().sendRequest({
        method: "signEthereumMessage",
        params: {
          address: G(r),
          message: i(o),
          typedDataJson: JSON.stringify(o, null, 2),
          addPrefix: false
        }
      });
      if (N(c)) throw c;
      return c.result;
    }
    initializeRelay() {
      return this._relay || (this._relay = new z({
        linkAPIUrl: $t,
        storage: this._storage,
        metadata: this.metadata,
        accountsCallback: this._setAddresses.bind(this),
        chainCallback: this.updateProviderInfo.bind(this)
      })), this._relay;
    }
  }
  const gs = "SignerType", _s = new K("CBWSDK", "SignerConfigurator");
  function cr() {
    return _s.getItem(gs);
  }
  function lr(t) {
    _s.setItem(gs, t);
  }
  async function dr(t) {
    const { communicator: e, metadata: n, handshakeRequest: s, callback: i } = t;
    ur(e, n, i).catch(() => {
    });
    const r = {
      id: crypto.randomUUID(),
      event: "selectSignerType",
      data: Object.assign(Object.assign({}, t.preference), {
        handshakeRequest: s
      })
    }, { data: o } = await e.postRequestAndWaitForResponse(r);
    return o;
  }
  function hr(t) {
    const { signerType: e, metadata: n, communicator: s, callback: i } = t;
    switch (e) {
      case "scw":
        return new Ws({
          metadata: n,
          callback: i,
          communicator: s
        });
      case "walletlink":
        return new ps({
          metadata: n,
          callback: i
        });
    }
  }
  async function ur(t, e, n) {
    await t.onMessage(({ event: i }) => i === "WalletLinkSessionRequest");
    const s = new ps({
      metadata: e,
      callback: n
    });
    t.postMessage({
      event: "WalletLinkUpdate",
      data: {
        session: s.getSession()
      }
    }), await s.handshake(), t.postMessage({
      event: "WalletLinkUpdate",
      data: {
        connected: true
      }
    });
  }
  const fr = `Coinbase Wallet SDK requires the Cross-Origin-Opener-Policy header to not be set to 'same-origin'. This is to ensure that the SDK can communicate with the Coinbase Smart Wallet app.

Please see https://www.smartwallet.dev/guides/tips/popup-tips#cross-origin-opener-policy for more information.`, pr = () => {
    let t;
    return {
      getCrossOriginOpenerPolicy: () => t === void 0 ? "undefined" : t,
      checkCrossOriginOpenerPolicy: async () => {
        if (typeof window > "u") {
          t = "non-browser-env";
          return;
        }
        try {
          const e = `${window.location.origin}${window.location.pathname}`, n = await fetch(e, {
            method: "HEAD"
          });
          if (!n.ok) throw new Error(`HTTP error! status: ${n.status}`);
          const s = n.headers.get("Cross-Origin-Opener-Policy");
          t = s ?? "null", t === "same-origin" && console.error(fr);
        } catch (e) {
          console.error("Error checking Cross-Origin-Opener-Policy:", e.message), t = "error";
        }
      }
    };
  }, { checkCrossOriginOpenerPolicy: gr, getCrossOriginOpenerPolicy: _r } = pr(), Yt = 420, Jt = 540;
  function mr(t) {
    const e = (window.innerWidth - Yt) / 2 + window.screenX, n = (window.innerHeight - Jt) / 2 + window.screenY;
    br(t);
    const s = `wallet_${crypto.randomUUID()}`, i = window.open(t, s, `width=${Yt}, height=${Jt}, left=${e}, top=${n}`);
    if (i == null ? void 0 : i.focus(), !i) throw v.rpc.internal("Pop up window failed to open");
    return i;
  }
  function yr(t) {
    t && !t.closed && t.close();
  }
  function br(t) {
    const e = {
      sdkName: un,
      sdkVersion: ke,
      origin: window.location.origin,
      coop: _r()
    };
    for (const [n, s] of Object.entries(e)) t.searchParams.append(n, s.toString());
  }
  class wr {
    constructor({ url: e = rr, metadata: n, preference: s }) {
      this.popup = null, this.listeners = /* @__PURE__ */ new Map(), this.postMessage = async (i) => {
        (await this.waitForPopupLoaded()).postMessage(i, this.url.origin);
      }, this.postRequestAndWaitForResponse = async (i) => {
        const r = this.onMessage(({ requestId: o }) => o === i.id);
        return this.postMessage(i), await r;
      }, this.onMessage = async (i) => new Promise((r, o) => {
        const a = (c) => {
          if (c.origin !== this.url.origin) return;
          const d = c.data;
          i(d) && (r(d), window.removeEventListener("message", a), this.listeners.delete(a));
        };
        window.addEventListener("message", a), this.listeners.set(a, {
          reject: o
        });
      }), this.disconnect = () => {
        yr(this.popup), this.popup = null, this.listeners.forEach(({ reject: i }, r) => {
          i(v.provider.userRejectedRequest("Request rejected")), window.removeEventListener("message", r);
        }), this.listeners.clear();
      }, this.waitForPopupLoaded = async () => this.popup && !this.popup.closed ? (this.popup.focus(), this.popup) : (this.popup = mr(this.url), this.onMessage(({ event: i }) => i === "PopupUnload").then(this.disconnect).catch(() => {
      }), this.onMessage(({ event: i }) => i === "PopupLoaded").then((i) => {
        this.postMessage({
          requestId: i.id,
          data: {
            version: ke,
            metadata: this.metadata,
            preference: this.preference,
            location: window.location.toString()
          }
        });
      }).then(() => {
        if (!this.popup) throw v.rpc.internal();
        return this.popup;
      })), this.url = new URL(e), this.metadata = n, this.preference = s;
    }
  }
  function vr(t) {
    const e = ks(kr(t), {
      shouldIncludeStack: true
    }), n = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
    return n.searchParams.set("version", ke), n.searchParams.set("code", e.code.toString()), n.searchParams.set("message", e.message), Object.assign(Object.assign({}, e), {
      docUrl: n.href
    });
  }
  function kr(t) {
    var e;
    if (typeof t == "string") return {
      message: t,
      code: M.rpc.internal
    };
    if (N(t)) {
      const n = t.errorMessage, s = (e = t.errorCode) !== null && e !== void 0 ? e : n.match(/(denied|rejected)/i) ? M.provider.userRejectedRequest : void 0;
      return Object.assign(Object.assign({}, t), {
        message: n,
        code: s,
        data: {
          method: t.method
        }
      });
    }
    return t;
  }
  var ms = {
    exports: {}
  };
  (function(t) {
    var e = Object.prototype.hasOwnProperty, n = "~";
    function s() {
    }
    Object.create && (s.prototype = /* @__PURE__ */ Object.create(null), new s().__proto__ || (n = false));
    function i(c, d, h) {
      this.fn = c, this.context = d, this.once = h || false;
    }
    function r(c, d, h, l, p) {
      if (typeof h != "function") throw new TypeError("The listener must be a function");
      var f = new i(h, l || c, p), m = n ? n + d : d;
      return c._events[m] ? c._events[m].fn ? c._events[m] = [
        c._events[m],
        f
      ] : c._events[m].push(f) : (c._events[m] = f, c._eventsCount++), c;
    }
    function o(c, d) {
      --c._eventsCount === 0 ? c._events = new s() : delete c._events[d];
    }
    function a() {
      this._events = new s(), this._eventsCount = 0;
    }
    a.prototype.eventNames = function() {
      var d = [], h, l;
      if (this._eventsCount === 0) return d;
      for (l in h = this._events) e.call(h, l) && d.push(n ? l.slice(1) : l);
      return Object.getOwnPropertySymbols ? d.concat(Object.getOwnPropertySymbols(h)) : d;
    }, a.prototype.listeners = function(d) {
      var h = n ? n + d : d, l = this._events[h];
      if (!l) return [];
      if (l.fn) return [
        l.fn
      ];
      for (var p = 0, f = l.length, m = new Array(f); p < f; p++) m[p] = l[p].fn;
      return m;
    }, a.prototype.listenerCount = function(d) {
      var h = n ? n + d : d, l = this._events[h];
      return l ? l.fn ? 1 : l.length : 0;
    }, a.prototype.emit = function(d, h, l, p, f, m) {
      var C = n ? n + d : d;
      if (!this._events[C]) return false;
      var g = this._events[C], b = arguments.length, w, k;
      if (g.fn) {
        switch (g.once && this.removeListener(d, g.fn, void 0, true), b) {
          case 1:
            return g.fn.call(g.context), true;
          case 2:
            return g.fn.call(g.context, h), true;
          case 3:
            return g.fn.call(g.context, h, l), true;
          case 4:
            return g.fn.call(g.context, h, l, p), true;
          case 5:
            return g.fn.call(g.context, h, l, p, f), true;
          case 6:
            return g.fn.call(g.context, h, l, p, f, m), true;
        }
        for (k = 1, w = new Array(b - 1); k < b; k++) w[k - 1] = arguments[k];
        g.fn.apply(g.context, w);
      } else {
        var U = g.length, H;
        for (k = 0; k < U; k++) switch (g[k].once && this.removeListener(d, g[k].fn, void 0, true), b) {
          case 1:
            g[k].fn.call(g[k].context);
            break;
          case 2:
            g[k].fn.call(g[k].context, h);
            break;
          case 3:
            g[k].fn.call(g[k].context, h, l);
            break;
          case 4:
            g[k].fn.call(g[k].context, h, l, p);
            break;
          default:
            if (!w) for (H = 1, w = new Array(b - 1); H < b; H++) w[H - 1] = arguments[H];
            g[k].fn.apply(g[k].context, w);
        }
      }
      return true;
    }, a.prototype.on = function(d, h, l) {
      return r(this, d, h, l, false);
    }, a.prototype.once = function(d, h, l) {
      return r(this, d, h, l, true);
    }, a.prototype.removeListener = function(d, h, l, p) {
      var f = n ? n + d : d;
      if (!this._events[f]) return this;
      if (!h) return o(this, f), this;
      var m = this._events[f];
      if (m.fn) m.fn === h && (!p || m.once) && (!l || m.context === l) && o(this, f);
      else {
        for (var C = 0, g = [], b = m.length; C < b; C++) (m[C].fn !== h || p && !m[C].once || l && m[C].context !== l) && g.push(m[C]);
        g.length ? this._events[f] = g.length === 1 ? g[0] : g : o(this, f);
      }
      return this;
    }, a.prototype.removeAllListeners = function(d) {
      var h;
      return d ? (h = n ? n + d : d, this._events[h] && o(this, h)) : (this._events = new s(), this._eventsCount = 0), this;
    }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = n, a.EventEmitter = a, t.exports = a;
  })(ms);
  var Er = ms.exports;
  const Cr = Qt(Er);
  class xr extends Cr {
  }
  var Sr = function(t, e) {
    var n = {};
    for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && e.indexOf(s) < 0 && (n[s] = t[s]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, s = Object.getOwnPropertySymbols(t); i < s.length; i++) e.indexOf(s[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, s[i]) && (n[s[i]] = t[s[i]]);
    return n;
  };
  class Ir extends xr {
    constructor(e) {
      var { metadata: n } = e, s = e.preference, { keysUrl: i } = s, r = Sr(s, [
        "keysUrl"
      ]);
      super(), this.signer = null, this.isCoinbaseWallet = true, this.metadata = n, this.preference = r, this.communicator = new wr({
        url: i,
        metadata: n,
        preference: r
      });
      const o = cr();
      o && (this.signer = this.initSigner(o));
    }
    async request(e) {
      try {
        if (Bs(e), !this.signer) switch (e.method) {
          case "eth_requestAccounts": {
            const n = await this.requestSignerSelection(e), s = this.initSigner(n);
            await s.handshake(e), this.signer = s, lr(n);
            break;
          }
          case "wallet_sendCalls": {
            const n = this.initSigner("scw");
            await n.handshake({
              method: "handshake"
            });
            const s = await n.request(e);
            return await n.cleanup(), s;
          }
          case "wallet_getCallsStatus":
            return lt(e, or);
          case "net_version":
            return 1;
          case "eth_chainId":
            return Q(1);
          default:
            throw v.provider.unauthorized("Must call 'eth_requestAccounts' before other methods");
        }
        return await this.signer.request(e);
      } catch (n) {
        const { code: s } = n;
        return s === M.provider.unauthorized && this.disconnect(), Promise.reject(vr(n));
      }
    }
    async enable() {
      return console.warn('.enable() has been deprecated. Please use .request({ method: "eth_requestAccounts" }) instead.'), await this.request({
        method: "eth_requestAccounts"
      });
    }
    async disconnect() {
      var e;
      await ((e = this.signer) === null || e === void 0 ? void 0 : e.cleanup()), this.signer = null, K.clearAll(), this.emit("disconnect", v.provider.disconnected("User initiated disconnection"));
    }
    requestSignerSelection(e) {
      return dr({
        communicator: this.communicator,
        preference: this.preference,
        metadata: this.metadata,
        handshakeRequest: e,
        callback: this.emit.bind(this)
      });
    }
    initSigner(e) {
      return hr({
        signerType: e,
        metadata: this.metadata,
        communicator: this.communicator,
        callback: this.emit.bind(this)
      });
    }
  }
  function Lr(t) {
    if (t) {
      if (![
        "all",
        "smartWalletOnly",
        "eoaOnly"
      ].includes(t.options)) throw new Error(`Invalid options: ${t.options}`);
      if (t.attribution && t.attribution.auto !== void 0 && t.attribution.dataSuffix !== void 0) throw new Error("Attribution cannot contain both auto and dataSuffix properties");
    }
  }
  Mr = class {
    constructor(e) {
      this.metadata = {
        appName: e.appName || "Dapp",
        appLogoUrl: e.appLogoUrl || As(),
        appChainIds: e.appChainIds || []
      }, this.storeLatestVersion(), gr();
    }
    makeWeb3Provider(e = {
      options: "all"
    }) {
      var n;
      Lr(e);
      const s = {
        metadata: this.metadata,
        preference: e
      };
      return (n = js(s)) !== null && n !== void 0 ? n : new Ir(s);
    }
    getCoinbaseWalletLogo(e, n = 240) {
      return bs(e, n);
    }
    storeLatestVersion() {
      new K("CBWSDK").setItem("VERSION", ke);
    }
  };
});
export {
  Mr as CoinbaseWalletSDK,
  __tla,
  Mr as default
};
