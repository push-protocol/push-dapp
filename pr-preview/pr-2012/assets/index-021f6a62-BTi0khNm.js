const Z="2.12.0",tt=()=>`viem@${Z}`;class c extends Error{constructor(e,s={}){var o;super(),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ViemError"}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:tt()});const i=s.cause instanceof c?s.cause.details:(o=s.cause)!=null&&o.message?s.cause.message:s.details,n=s.cause instanceof c&&s.cause.docsPath||s.docsPath;this.message=[e||"An error occurred.","",...s.metaMessages?[...s.metaMessages,""]:[],...n?[`Docs: https://viem.sh${n}${s.docsSlug?`#${s.docsSlug}`:""}`]:[],...i?[`Details: ${i}`]:[],`Version: ${this.version}`].join(`
`),s.cause&&(this.cause=s.cause),this.details=i,this.docsPath=n,this.metaMessages=s.metaMessages,this.shortMessage=e}walk(e){return U(this,e)}}function U(t,e){return e!=null&&e(t)?t:t&&typeof t=="object"&&"cause"in t?U(t.cause,e):e?null:t}class et extends c{constructor({max:e,min:s,signed:i,size:n,value:o}){super(`Number "${o}" is not in safe ${n?`${n*8}-bit ${i?"signed":"unsigned"} `:""}integer range ${e?`(${s} to ${e})`:`(above ${s})`}`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"IntegerOutOfRangeError"})}}class st extends c{constructor({givenSize:e,maxSize:s}){super(`Size cannot exceed ${s} bytes. Given size: ${e} bytes.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SizeOverflowError"})}}function g(t,{strict:e=!0}={}){return!t||typeof t!="string"?!1:e?/^0x[0-9a-fA-F]*$/.test(t):t.startsWith("0x")}function b(t){return g(t,{strict:!1})?Math.ceil((t.length-2)/2):t.length}function it(t,{dir:e="left"}={}){let s=typeof t=="string"?t.replace("0x",""):t,i=0;for(let n=0;n<s.length-1&&s[e==="left"?n:s.length-n-1].toString()==="0";n++)i++;return s=e==="left"?s.slice(i):s.slice(0,s.length-i),typeof t=="string"?(s.length===1&&e==="right"&&(s=`${s}0`),`0x${s.length%2===1?`0${s}`:s}`):s}class nt extends c{constructor({offset:e,position:s,size:i}){super(`Slice ${s==="start"?"starting":"ending"} at offset "${e}" is out-of-bounds (size: ${i}).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SliceOffsetOutOfBoundsError"})}}class L extends c{constructor({size:e,targetSize:s,type:i}){super(`${i.charAt(0).toUpperCase()}${i.slice(1).toLowerCase()} size (${e}) exceeds padding size (${s}).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SizeExceedsPaddingSizeError"})}}function d(t,{dir:e,size:s=32}={}){return typeof t=="string"?rt(t,{dir:e,size:s}):ot(t,{dir:e,size:s})}function rt(t,{dir:e,size:s=32}={}){if(s===null)return t;const i=t.replace("0x","");if(i.length>s*2)throw new L({size:Math.ceil(i.length/2),targetSize:s,type:"hex"});return`0x${i[e==="right"?"padEnd":"padStart"](s*2,"0")}`}function ot(t,{dir:e,size:s=32}={}){if(s===null)return t;if(t.length>s)throw new L({size:t.length,targetSize:s,type:"bytes"});const i=new Uint8Array(s);for(let n=0;n<s;n++){const o=e==="right";i[o?n:s-n-1]=t[o?n:t.length-n-1]}return i}const at=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function ct(t,e={}){return typeof t=="number"||typeof t=="bigint"?S(t,e):typeof t=="string"?lt(t,e):typeof t=="boolean"?ut(t,e):v(t,e)}function ut(t,e={}){const s=`0x${Number(t)}`;return typeof e.size=="number"?(p(s,{size:e.size}),d(s,{size:e.size})):s}function v(t,e={}){let s="";for(let n=0;n<t.length;n++)s+=at[t[n]];const i=`0x${s}`;return typeof e.size=="number"?(p(i,{size:e.size}),d(i,{dir:"right",size:e.size})):i}function S(t,e={}){const{signed:s,size:i}=e,n=BigInt(t);let o;i?s?o=(1n<<BigInt(i)*8n-1n)-1n:o=2n**(BigInt(i)*8n)-1n:typeof t=="number"&&(o=BigInt(Number.MAX_SAFE_INTEGER));const r=typeof o=="bigint"&&s?-o-1n:0;if(o&&n>o||n<r){const u=typeof t=="bigint"?"n":"";throw new et({max:o?`${o}${u}`:void 0,min:`${r}${u}`,signed:s,size:i,value:`${t}${u}`})}const a=`0x${(s&&n<0?(1n<<BigInt(i*8))+BigInt(n):n).toString(16)}`;return i?d(a,{size:i}):a}const ht=new TextEncoder;function lt(t,e={}){const s=ht.encode(t);return v(s,e)}const ft=new TextEncoder;function A(t,e={}){return typeof t=="number"||typeof t=="bigint"?pt(t,e):typeof t=="boolean"?dt(t,e):g(t)?x(t,e):B(t,e)}function dt(t,e={}){const s=new Uint8Array(1);return s[0]=Number(t),typeof e.size=="number"?(p(s,{size:e.size}),d(s,{size:e.size})):s}const h={zero:48,nine:57,A:65,F:70,a:97,f:102};function j(t){if(t>=h.zero&&t<=h.nine)return t-h.zero;if(t>=h.A&&t<=h.F)return t-(h.A-10);if(t>=h.a&&t<=h.f)return t-(h.a-10)}function x(t,e={}){let s=t;e.size&&(p(s,{size:e.size}),s=d(s,{dir:"right",size:e.size}));let i=s.slice(2);i.length%2&&(i=`0${i}`);const n=i.length/2,o=new Uint8Array(n);for(let r=0,a=0;r<n;r++){const u=j(i.charCodeAt(a++)),l=j(i.charCodeAt(a++));if(u===void 0||l===void 0)throw new c(`Invalid byte sequence ("${i[a-2]}${i[a-1]}" in "${i}").`);o[r]=u*16+l}return o}function pt(t,e){const s=S(t,e);return x(s)}function B(t,e={}){const s=ft.encode(t);return typeof e.size=="number"?(p(s,{size:e.size}),d(s,{dir:"right",size:e.size})):s}function p(t,{size:e}){if(b(t)>e)throw new st({givenSize:b(t),maxSize:e})}function R(t,e={}){const{signed:s}=e;e.size&&p(t,{size:e.size});const i=BigInt(t);if(!s)return i;const n=(t.length-2)/2,o=(1n<<BigInt(n)*8n-1n)-1n;return i<=o?i:i-BigInt(`0x${"f".padStart(n*2,"f")}`)-1n}function gt(t,e={}){return Number(R(t,e))}function bt(t,e){return({exclude:s,format:i})=>({exclude:s,format:n=>{const o=e(n);if(s)for(const r of s)delete o[r];return{...o,...i(n)}},type:t})}class yt extends c{constructor({address:e}){super(`Address "${e}" is invalid.`,{metaMessages:["- Address must be a hex value of 20 bytes (40 hex characters).","- Address must match its checksum counterpart."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAddressError"})}}class k extends Map{constructor(e){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=e}set(e,s){return super.set(e,s),this.maxSize&&this.size>this.maxSize&&this.delete(this.keys().next().value),this}}function C(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function M(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function $(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function T(t,e){M(t);const s=e.outputLen;if(t.length<s)throw new Error(`digestInto() expects output buffer of length at least ${s}`)}const w=BigInt(2**32-1),F=BigInt(32);function mt(t,e=!1){return e?{h:Number(t&w),l:Number(t>>F&w)}:{h:Number(t>>F&w)|0,l:Number(t&w)|0}}function wt(t,e=!1){let s=new Uint32Array(t.length),i=new Uint32Array(t.length);for(let n=0;n<t.length;n++){const{h:o,l:r}=mt(t[n],e);[s[n],i[n]]=[o,r]}return[s,i]}const vt=(t,e,s)=>t<<s|e>>>32-s,xt=(t,e,s)=>e<<s|t>>>32-s,$t=(t,e,s)=>e<<s-32|t>>>64-s,zt=(t,e,s)=>t<<s-32|e>>>64-s;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Pt=t=>t instanceof Uint8Array,Ot=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),It=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),Et=(t,e)=>t<<32-e|t>>>e,Ut=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Ut)throw new Error("Non little-endian hardware is not supported");function Lt(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function z(t){if(typeof t=="string"&&(t=Lt(t)),!Pt(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}class N{clone(){return this._cloneInto()}}function V(t){const e=i=>t().update(z(i)).digest(),s=t();return e.outputLen=s.outputLen,e.blockLen=s.blockLen,e.create=()=>t(),e}const[_,G,D]=[[],[],[]],St=BigInt(0),y=BigInt(1),At=BigInt(2),jt=BigInt(7),Bt=BigInt(256),Rt=BigInt(113);for(let t=0,e=y,s=1,i=0;t<24;t++){[s,i]=[i,(2*s+3*i)%5],_.push(2*(5*i+s)),G.push((t+1)*(t+2)/2%64);let n=St;for(let o=0;o<7;o++)e=(e<<y^(e>>jt)*Rt)%Bt,e&At&&(n^=y<<(y<<BigInt(o))-y);D.push(n)}const[kt,Ct]=wt(D,!0),X=(t,e,s)=>s>32?$t(t,e,s):vt(t,e,s),H=(t,e,s)=>s>32?zt(t,e,s):xt(t,e,s);function Mt(t,e=24){const s=new Uint32Array(10);for(let i=24-e;i<24;i++){for(let r=0;r<10;r++)s[r]=t[r]^t[r+10]^t[r+20]^t[r+30]^t[r+40];for(let r=0;r<10;r+=2){const a=(r+8)%10,u=(r+2)%10,l=s[u],f=s[u+1],J=X(l,f,1)^s[a],Q=H(l,f,1)^s[a+1];for(let m=0;m<50;m+=10)t[r+m]^=J,t[r+m+1]^=Q}let n=t[2],o=t[3];for(let r=0;r<24;r++){const a=G[r],u=X(n,o,a),l=H(n,o,a),f=_[r];n=t[f],o=t[f+1],t[f]=u,t[f+1]=l}for(let r=0;r<50;r+=10){for(let a=0;a<10;a++)s[a]=t[r+a];for(let a=0;a<10;a++)t[r+a]^=~s[(a+2)%10]&s[(a+4)%10]}t[0]^=kt[i],t[1]^=Ct[i]}s.fill(0)}class E extends N{constructor(e,s,i,n=!1,o=24){if(super(),this.blockLen=e,this.suffix=s,this.outputLen=i,this.enableXOF=n,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,C(i),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=Ot(this.state)}keccak(){Mt(this.state32,this.rounds),this.posOut=0,this.pos=0}update(e){$(this);const{blockLen:s,state:i}=this;e=z(e);const n=e.length;for(let o=0;o<n;){const r=Math.min(s-this.pos,n-o);for(let a=0;a<r;a++)i[this.pos++]^=e[o++];this.pos===s&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:s,pos:i,blockLen:n}=this;e[i]^=s,s&128&&i===n-1&&this.keccak(),e[n-1]^=128,this.keccak()}writeInto(e){$(this,!1),M(e),this.finish();const s=this.state,{blockLen:i}=this;for(let n=0,o=e.length;n<o;){this.posOut>=i&&this.keccak();const r=Math.min(i-this.posOut,o-n);e.set(s.subarray(this.posOut,this.posOut+r),n),this.posOut+=r,n+=r}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return C(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(T(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:s,suffix:i,outputLen:n,rounds:o,enableXOF:r}=this;return e||(e=new E(s,i,n,r,o)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=i,e.outputLen=n,e.enableXOF=r,e.destroyed=this.destroyed,e}}const Tt=(t,e,s)=>V(()=>new E(e,t,s)),Ft=Tt(1,136,256/8);function Nt(t,e){return Ft(g(t,{strict:!1})?A(t):t)}const P=new k(8192);function Vt(t,e){if(P.has(`${t}.${e}`))return P.get(`${t}.${e}`);const s=t.substring(2).toLowerCase(),i=Nt(B(s)),n=s.split("");for(let r=0;r<40;r+=2)i[r>>1]>>4>=8&&n[r]&&(n[r]=n[r].toUpperCase()),(i[r>>1]&15)>=8&&n[r+1]&&(n[r+1]=n[r+1].toUpperCase());const o=`0x${n.join("")}`;return P.set(`${t}.${e}`,o),o}const _t=/^0x[a-fA-F0-9]{40}$/,O=new k(8192);function Gt(t,e){const{strict:s=!0}=e??{};if(O.has(t))return O.get(t);const i=_t.test(t)?t.toLowerCase()===t?!0:s?Vt(t)===t:!0:!1;return O.set(t,i),i}function Dt(t){return`0x${t.reduce((e,s)=>e+s.replace("0x",""),"")}`}class W extends c{constructor({offset:e}){super(`Offset \`${e}\` cannot be negative.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"NegativeOffsetError"})}}class Xt extends c{constructor({length:e,position:s}){super(`Position \`${s}\` is out of bounds (\`0 < position < ${e}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PositionOutOfBoundsError"})}}class Ht extends c{constructor({count:e,limit:s}){super(`Recursive read limit of \`${s}\` exceeded (recursive read count: \`${e}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"RecursiveReadLimitExceededError"})}}const Wt={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:Number.POSITIVE_INFINITY,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new Ht({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(t){if(t<0||t>this.bytes.length-1)throw new Xt({length:this.bytes.length,position:t})},decrementPosition(t){if(t<0)throw new W({offset:t});const e=this.position-t;this.assertPosition(e),this.position=e},getReadCount(t){return this.positionReadCount.get(t||this.position)||0},incrementPosition(t){if(t<0)throw new W({offset:t});const e=this.position+t;this.assertPosition(e),this.position=e},inspectByte(t){const e=t??this.position;return this.assertPosition(e),this.bytes[e]},inspectBytes(t,e){const s=e??this.position;return this.assertPosition(s+t-1),this.bytes.subarray(s,s+t)},inspectUint8(t){const e=t??this.position;return this.assertPosition(e),this.bytes[e]},inspectUint16(t){const e=t??this.position;return this.assertPosition(e+1),this.dataView.getUint16(e)},inspectUint24(t){const e=t??this.position;return this.assertPosition(e+2),(this.dataView.getUint16(e)<<8)+this.dataView.getUint8(e+2)},inspectUint32(t){const e=t??this.position;return this.assertPosition(e+3),this.dataView.getUint32(e)},pushByte(t){this.assertPosition(this.position),this.bytes[this.position]=t,this.position++},pushBytes(t){this.assertPosition(this.position+t.length-1),this.bytes.set(t,this.position),this.position+=t.length},pushUint8(t){this.assertPosition(this.position),this.bytes[this.position]=t,this.position++},pushUint16(t){this.assertPosition(this.position+1),this.dataView.setUint16(this.position,t),this.position+=2},pushUint24(t){this.assertPosition(this.position+2),this.dataView.setUint16(this.position,t>>8),this.dataView.setUint8(this.position+2,t&255),this.position+=3},pushUint32(t){this.assertPosition(this.position+3),this.dataView.setUint32(this.position,t),this.position+=4},readByte(){this.assertReadLimit(),this._touch();const t=this.inspectByte();return this.position++,t},readBytes(t,e){this.assertReadLimit(),this._touch();const s=this.inspectBytes(t);return this.position+=e??t,s},readUint8(){this.assertReadLimit(),this._touch();const t=this.inspectUint8();return this.position+=1,t},readUint16(){this.assertReadLimit(),this._touch();const t=this.inspectUint16();return this.position+=2,t},readUint24(){this.assertReadLimit(),this._touch();const t=this.inspectUint24();return this.position+=3,t},readUint32(){this.assertReadLimit(),this._touch();const t=this.inspectUint32();return this.position+=4,t},get remaining(){return this.bytes.length-this.position},setPosition(t){const e=this.position;return this.assertPosition(t),this.position=t,()=>this.position=e},_touch(){if(this.recursiveReadLimit===Number.POSITIVE_INFINITY)return;const t=this.getReadCount();this.positionReadCount.set(this.position,t+1),t>0&&this.recursiveReadCount++}};function qt(t,{recursiveReadLimit:e=8192}={}){const s=Object.create(Wt);return s.bytes=t,s.dataView=new DataView(t.buffer,t.byteOffset,t.byteLength),s.positionReadCount=new Map,s.recursiveReadLimit=e,s}const Kt={ether:-9,wei:9};function Yt(t,e){let s=t.toString();const i=s.startsWith("-");i&&(s=s.slice(1)),s=s.padStart(e,"0");let[n,o]=[s.slice(0,s.length-e),s.slice(s.length-e)];return o=o.replace(/(0+)$/,""),`${i?"-":""}${n||"0"}${o?`.${o}`:""}`}function I(t,e="wei"){return Yt(t,Kt[e])}function Jt(t){const e=Object.entries(t).map(([i,n])=>n===void 0||n===!1?null:[i,n]).filter(Boolean),s=e.reduce((i,[n])=>Math.max(i,n.length),0);return e.map(([i,n])=>`  ${`${i}:`.padEnd(s+1)}  ${n}`).join(`
`)}class Qt extends c{constructor({v:e}){super(`Invalid \`v\` value "${e}". Expected 27 or 28.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidLegacyVError"})}}class Zt extends c{constructor({transaction:e}){super("Cannot infer a transaction type from provided transaction.",{metaMessages:["Provided Transaction:","{",Jt(e),"}","","To infer the type, either provide:","- a `type` to the Transaction, or","- an EIP-1559 Transaction with `maxFeePerGas`, or","- an EIP-2930 Transaction with `gasPrice` & `accessList`, or","- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or","- a Legacy Transaction with `gasPrice`"]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidSerializableTransactionError"})}}class te extends c{constructor({storageKey:e}){super(`Size for storage key "${e}" is invalid. Expected 32 bytes. Got ${Math.floor((e.length-2)/2)} bytes.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidStorageKeySizeError"})}}class ee extends c{constructor({chainId:e}){super(typeof e=="number"?`Chain ID "${e}" is invalid.`:"Chain ID is invalid."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidChainIdError"})}}class q extends c{constructor({cause:e,maxFeePerGas:s}={}){super(`The fee cap (\`maxFeePerGas\`${s?` = ${I(s)} gwei`:""}) cannot be higher than the maximum allowed value (2^256-1).`,{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"FeeCapTooHigh"})}}Object.defineProperty(q,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/});class K extends c{constructor({cause:e,maxPriorityFeePerGas:s,maxFeePerGas:i}={}){super([`The provided tip (\`maxPriorityFeePerGas\`${s?` = ${I(s)} gwei`:""}) cannot be higher than the fee cap (\`maxFeePerGas\`${i?` = ${I(i)} gwei`:""}).`].join(`
`),{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"TipAboveFeeCapError"})}}Object.defineProperty(K,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max priority fee per gas higher than max fee per gas|tip higher than fee cap/});function se(t,e,s,{strict:i}={}){return g(t,{strict:!1})?ne(t,e,s,{strict:i}):ie(t,e,s,{strict:i})}function Y(t,e,s){if(b(t)!==s-e)throw new nt({offset:s,position:"end",size:b(t)})}function ie(t,e,s,{strict:i}={}){const n=t.slice(e,s);return i&&Y(n,e,s),n}function ne(t,e,s,{strict:i}={}){const n=`0x${t.replace("0x","").slice(e*2,s*2)}`;return i&&Y(n,e,s),n}const re=Object.freeze(Object.defineProperty({__proto__:null},Symbol.toStringTag,{value:"Module"}));export{c as B,q as F,N as H,yt as I,K as T,gt as a,qt as b,Dt as c,bt as d,v as e,Zt as f,Qt as g,R as h,Gt as i,ee as j,te as k,it as l,se as m,x as n,A as o,g as p,It as q,$ as r,b as s,ct as t,z as u,T as v,V as w,Et as x,re as y};
